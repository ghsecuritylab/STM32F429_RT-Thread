ARM GAS  /tmp/cchS3cuE.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"mem.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.plug_holes,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	plug_holes:
  25              	.LFB15:
  26              		.file 1 "rt-thread/src/mem.c"
   1:rt-thread/src/mem.c **** /*
   2:rt-thread/src/mem.c ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt-thread/src/mem.c ****  *
   4:rt-thread/src/mem.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt-thread/src/mem.c ****  *
   6:rt-thread/src/mem.c ****  * Change Logs:
   7:rt-thread/src/mem.c ****  * Date           Author       Notes
   8:rt-thread/src/mem.c ****  * 2008-7-12      Bernard      the first version
   9:rt-thread/src/mem.c ****  * 2010-06-09     Bernard      fix the end stub of heap
  10:rt-thread/src/mem.c ****  *                             fix memory check in rt_realloc function
  11:rt-thread/src/mem.c ****  * 2010-07-13     Bernard      fix RT_ALIGN issue found by kuronca
  12:rt-thread/src/mem.c ****  * 2010-10-14     Bernard      fix rt_realloc issue when realloc a NULL pointer.
  13:rt-thread/src/mem.c ****  * 2017-07-14     armink       fix rt_realloc issue when new size is 0
  14:rt-thread/src/mem.c ****  * 2018-10-02     Bernard      Add 64bit support
  15:rt-thread/src/mem.c ****  */
  16:rt-thread/src/mem.c **** 
  17:rt-thread/src/mem.c **** /*
  18:rt-thread/src/mem.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  19:rt-thread/src/mem.c ****  * All rights reserved.
  20:rt-thread/src/mem.c ****  *
  21:rt-thread/src/mem.c ****  * Redistribution and use in source and binary forms, with or without modification,
  22:rt-thread/src/mem.c ****  * are permitted provided that the following conditions are met:
  23:rt-thread/src/mem.c ****  *
  24:rt-thread/src/mem.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  25:rt-thread/src/mem.c ****  *    this list of conditions and the following disclaimer.
  26:rt-thread/src/mem.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  27:rt-thread/src/mem.c ****  *    this list of conditions and the following disclaimer in the documentation
  28:rt-thread/src/mem.c ****  *    and/or other materials provided with the distribution.
  29:rt-thread/src/mem.c ****  * 3. The name of the author may not be used to endorse or promote products
  30:rt-thread/src/mem.c ****  *    derived from this software without specific prior written permission.
  31:rt-thread/src/mem.c ****  *
  32:rt-thread/src/mem.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
ARM GAS  /tmp/cchS3cuE.s 			page 2


  33:rt-thread/src/mem.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  34:rt-thread/src/mem.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  35:rt-thread/src/mem.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  36:rt-thread/src/mem.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  37:rt-thread/src/mem.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  38:rt-thread/src/mem.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  39:rt-thread/src/mem.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  40:rt-thread/src/mem.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  41:rt-thread/src/mem.c ****  * OF SUCH DAMAGE.
  42:rt-thread/src/mem.c ****  *
  43:rt-thread/src/mem.c ****  * This file is part of the lwIP TCP/IP stack.
  44:rt-thread/src/mem.c ****  *
  45:rt-thread/src/mem.c ****  * Author: Adam Dunkels <adam@sics.se>
  46:rt-thread/src/mem.c ****  *         Simon Goldschmidt
  47:rt-thread/src/mem.c ****  *
  48:rt-thread/src/mem.c ****  */
  49:rt-thread/src/mem.c **** 
  50:rt-thread/src/mem.c **** #include <rthw.h>
  51:rt-thread/src/mem.c **** #include <rtthread.h>
  52:rt-thread/src/mem.c **** 
  53:rt-thread/src/mem.c **** #ifndef RT_USING_MEMHEAP_AS_HEAP
  54:rt-thread/src/mem.c **** 
  55:rt-thread/src/mem.c **** /* #define RT_MEM_DEBUG */
  56:rt-thread/src/mem.c **** #define RT_MEM_STATS
  57:rt-thread/src/mem.c **** 
  58:rt-thread/src/mem.c **** #if defined (RT_USING_HEAP) && defined (RT_USING_SMALL_MEM)
  59:rt-thread/src/mem.c **** #ifdef RT_USING_HOOK
  60:rt-thread/src/mem.c **** static void (*rt_malloc_hook)(void *ptr, rt_size_t size);
  61:rt-thread/src/mem.c **** static void (*rt_free_hook)(void *ptr);
  62:rt-thread/src/mem.c **** 
  63:rt-thread/src/mem.c **** /**
  64:rt-thread/src/mem.c ****  * @addtogroup Hook
  65:rt-thread/src/mem.c ****  */
  66:rt-thread/src/mem.c **** 
  67:rt-thread/src/mem.c **** /**@{*/
  68:rt-thread/src/mem.c **** 
  69:rt-thread/src/mem.c **** /**
  70:rt-thread/src/mem.c ****  * This function will set a hook function, which will be invoked when a memory
  71:rt-thread/src/mem.c ****  * block is allocated from heap memory.
  72:rt-thread/src/mem.c ****  *
  73:rt-thread/src/mem.c ****  * @param hook the hook function
  74:rt-thread/src/mem.c ****  */
  75:rt-thread/src/mem.c **** void rt_malloc_sethook(void (*hook)(void *ptr, rt_size_t size))
  76:rt-thread/src/mem.c **** {
  77:rt-thread/src/mem.c ****     rt_malloc_hook = hook;
  78:rt-thread/src/mem.c **** }
  79:rt-thread/src/mem.c **** 
  80:rt-thread/src/mem.c **** /**
  81:rt-thread/src/mem.c ****  * This function will set a hook function, which will be invoked when a memory
  82:rt-thread/src/mem.c ****  * block is released to heap memory.
  83:rt-thread/src/mem.c ****  *
  84:rt-thread/src/mem.c ****  * @param hook the hook function
  85:rt-thread/src/mem.c ****  */
  86:rt-thread/src/mem.c **** void rt_free_sethook(void (*hook)(void *ptr))
  87:rt-thread/src/mem.c **** {
  88:rt-thread/src/mem.c ****     rt_free_hook = hook;
  89:rt-thread/src/mem.c **** }
ARM GAS  /tmp/cchS3cuE.s 			page 3


  90:rt-thread/src/mem.c **** 
  91:rt-thread/src/mem.c **** /**@}*/
  92:rt-thread/src/mem.c **** 
  93:rt-thread/src/mem.c **** #endif
  94:rt-thread/src/mem.c **** 
  95:rt-thread/src/mem.c **** #define HEAP_MAGIC 0x1ea0
  96:rt-thread/src/mem.c **** struct heap_mem
  97:rt-thread/src/mem.c **** {
  98:rt-thread/src/mem.c ****     /* magic and used flag */
  99:rt-thread/src/mem.c ****     rt_uint16_t magic;
 100:rt-thread/src/mem.c ****     rt_uint16_t used;
 101:rt-thread/src/mem.c **** #ifdef ARCH_CPU_64BIT
 102:rt-thread/src/mem.c ****     rt_uint32_t resv;
 103:rt-thread/src/mem.c **** #endif
 104:rt-thread/src/mem.c **** 
 105:rt-thread/src/mem.c ****     rt_size_t next, prev;
 106:rt-thread/src/mem.c **** 
 107:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 108:rt-thread/src/mem.c **** #ifdef ARCH_CPU_64BIT
 109:rt-thread/src/mem.c ****     rt_uint8_t thread[8];
 110:rt-thread/src/mem.c **** #else
 111:rt-thread/src/mem.c ****     rt_uint8_t thread[4];   /* thread name */
 112:rt-thread/src/mem.c **** #endif
 113:rt-thread/src/mem.c **** #endif
 114:rt-thread/src/mem.c **** };
 115:rt-thread/src/mem.c **** 
 116:rt-thread/src/mem.c **** /** pointer to the heap: for alignment, heap_ptr is now a pointer instead of an array */
 117:rt-thread/src/mem.c **** static rt_uint8_t *heap_ptr;
 118:rt-thread/src/mem.c **** 
 119:rt-thread/src/mem.c **** /** the last entry, always unused! */
 120:rt-thread/src/mem.c **** static struct heap_mem *heap_end;
 121:rt-thread/src/mem.c **** 
 122:rt-thread/src/mem.c **** #ifdef ARCH_CPU_64BIT
 123:rt-thread/src/mem.c **** #define MIN_SIZE 24
 124:rt-thread/src/mem.c **** #else
 125:rt-thread/src/mem.c **** #define MIN_SIZE 12
 126:rt-thread/src/mem.c **** #endif
 127:rt-thread/src/mem.c **** 
 128:rt-thread/src/mem.c **** #define MIN_SIZE_ALIGNED     RT_ALIGN(MIN_SIZE, RT_ALIGN_SIZE)
 129:rt-thread/src/mem.c **** #define SIZEOF_STRUCT_MEM    RT_ALIGN(sizeof(struct heap_mem), RT_ALIGN_SIZE)
 130:rt-thread/src/mem.c **** 
 131:rt-thread/src/mem.c **** static struct heap_mem *lfree;   /* pointer to the lowest free block */
 132:rt-thread/src/mem.c **** 
 133:rt-thread/src/mem.c **** static struct rt_semaphore heap_sem;
 134:rt-thread/src/mem.c **** static rt_size_t mem_size_aligned;
 135:rt-thread/src/mem.c **** 
 136:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 137:rt-thread/src/mem.c **** static rt_size_t used_mem, max_mem;
 138:rt-thread/src/mem.c **** #endif
 139:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 140:rt-thread/src/mem.c **** rt_inline void rt_mem_setname(struct heap_mem *mem, const char *name)
 141:rt-thread/src/mem.c **** {
 142:rt-thread/src/mem.c ****     int index;
 143:rt-thread/src/mem.c ****     for (index = 0; index < sizeof(mem->thread); index ++)
 144:rt-thread/src/mem.c ****     {
 145:rt-thread/src/mem.c ****         if (name[index] == '\0') break;
 146:rt-thread/src/mem.c ****         mem->thread[index] = name[index];
ARM GAS  /tmp/cchS3cuE.s 			page 4


 147:rt-thread/src/mem.c ****     }
 148:rt-thread/src/mem.c **** 
 149:rt-thread/src/mem.c ****     for (; index < sizeof(mem->thread); index ++)
 150:rt-thread/src/mem.c ****     {
 151:rt-thread/src/mem.c ****         mem->thread[index] = ' ';
 152:rt-thread/src/mem.c ****     }
 153:rt-thread/src/mem.c **** }
 154:rt-thread/src/mem.c **** #endif
 155:rt-thread/src/mem.c **** 
 156:rt-thread/src/mem.c **** static void plug_holes(struct heap_mem *mem)
 157:rt-thread/src/mem.c **** {
  27              		.loc 1 157 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 10B5     		push	{r4, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 4, -8
  36              		.cfi_offset 14, -4
  37 0002 0446     		mov	r4, r0
 158:rt-thread/src/mem.c ****     struct heap_mem *nmem;
 159:rt-thread/src/mem.c ****     struct heap_mem *pmem;
 160:rt-thread/src/mem.c **** 
 161:rt-thread/src/mem.c ****     RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
  38              		.loc 1 161 0
  39 0004 244B     		ldr	r3, .L15
  40 0006 1B68     		ldr	r3, [r3]
  41 0008 8342     		cmp	r3, r0
  42 000a 2DD8     		bhi	.L10
  43              	.LVL1:
  44              	.L2:
 162:rt-thread/src/mem.c ****     RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
  45              		.loc 1 162 0
  46 000c 234B     		ldr	r3, .L15+4
  47 000e 1B68     		ldr	r3, [r3]
  48 0010 9C42     		cmp	r4, r3
  49 0012 2FD2     		bcs	.L11
  50              	.L3:
 163:rt-thread/src/mem.c ****     RT_ASSERT(mem->used == 0);
  51              		.loc 1 163 0
  52 0014 6388     		ldrh	r3, [r4, #2]
  53 0016 002B     		cmp	r3, #0
  54 0018 32D1     		bne	.L12
  55              	.L4:
 164:rt-thread/src/mem.c **** 
 165:rt-thread/src/mem.c ****     /* plug hole forward */
 166:rt-thread/src/mem.c ****     nmem = (struct heap_mem *)&heap_ptr[mem->next];
  56              		.loc 1 166 0
  57 001a 1F4B     		ldr	r3, .L15
  58 001c 1968     		ldr	r1, [r3]
  59 001e 6268     		ldr	r2, [r4, #4]
  60 0020 0A44     		add	r2, r2, r1
  61              	.LVL2:
 167:rt-thread/src/mem.c ****     if (mem != nmem &&
  62              		.loc 1 167 0
ARM GAS  /tmp/cchS3cuE.s 			page 5


  63 0022 9442     		cmp	r4, r2
  64 0024 0FD0     		beq	.L5
 168:rt-thread/src/mem.c ****         nmem->used == 0 &&
  65              		.loc 1 168 0 discriminator 1
  66 0026 5388     		ldrh	r3, [r2, #2]
 167:rt-thread/src/mem.c ****     if (mem != nmem &&
  67              		.loc 1 167 0 discriminator 1
  68 0028 6BB9     		cbnz	r3, .L5
 169:rt-thread/src/mem.c ****         (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
  69              		.loc 1 169 0
  70 002a 1C4B     		ldr	r3, .L15+4
  71 002c 1B68     		ldr	r3, [r3]
 168:rt-thread/src/mem.c ****         nmem->used == 0 &&
  72              		.loc 1 168 0
  73 002e 9A42     		cmp	r2, r3
  74 0030 09D0     		beq	.L5
 170:rt-thread/src/mem.c ****     {
 171:rt-thread/src/mem.c ****         /* if mem->next is unused and not end of heap_ptr,
 172:rt-thread/src/mem.c ****          * combine mem and mem->next
 173:rt-thread/src/mem.c ****          */
 174:rt-thread/src/mem.c ****         if (lfree == nmem)
  75              		.loc 1 174 0
  76 0032 1B4B     		ldr	r3, .L15+8
  77 0034 1B68     		ldr	r3, [r3]
  78 0036 9A42     		cmp	r2, r3
  79 0038 28D0     		beq	.L13
  80              	.L6:
 175:rt-thread/src/mem.c ****         {
 176:rt-thread/src/mem.c ****             lfree = mem;
 177:rt-thread/src/mem.c ****         }
 178:rt-thread/src/mem.c ****         mem->next = nmem->next;
  81              		.loc 1 178 0
  82 003a 5368     		ldr	r3, [r2, #4]
  83 003c 6360     		str	r3, [r4, #4]
 179:rt-thread/src/mem.c ****         ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
  84              		.loc 1 179 0
  85 003e 5368     		ldr	r3, [r2, #4]
  86 0040 0B44     		add	r3, r3, r1
  87 0042 621A     		subs	r2, r4, r1
  88              	.LVL3:
  89 0044 9A60     		str	r2, [r3, #8]
  90              	.L5:
 180:rt-thread/src/mem.c ****     }
 181:rt-thread/src/mem.c **** 
 182:rt-thread/src/mem.c ****     /* plug hole backward */
 183:rt-thread/src/mem.c ****     pmem = (struct heap_mem *)&heap_ptr[mem->prev];
  91              		.loc 1 183 0
  92 0046 A368     		ldr	r3, [r4, #8]
  93 0048 0B44     		add	r3, r3, r1
  94              	.LVL4:
 184:rt-thread/src/mem.c ****     if (pmem != mem && pmem->used == 0)
  95              		.loc 1 184 0
  96 004a 9C42     		cmp	r4, r3
  97 004c 0BD0     		beq	.L1
  98              		.loc 1 184 0 is_stmt 0 discriminator 1
  99 004e 5A88     		ldrh	r2, [r3, #2]
 100 0050 4AB9     		cbnz	r2, .L1
ARM GAS  /tmp/cchS3cuE.s 			page 6


 185:rt-thread/src/mem.c ****     {
 186:rt-thread/src/mem.c ****         /* if mem->prev is unused, combine mem and mem->prev */
 187:rt-thread/src/mem.c ****         if (lfree == mem)
 101              		.loc 1 187 0 is_stmt 1
 102 0052 134A     		ldr	r2, .L15+8
 103 0054 1268     		ldr	r2, [r2]
 104 0056 9442     		cmp	r4, r2
 105 0058 1BD0     		beq	.L14
 106              	.L8:
 188:rt-thread/src/mem.c ****         {
 189:rt-thread/src/mem.c ****             lfree = pmem;
 190:rt-thread/src/mem.c ****         }
 191:rt-thread/src/mem.c ****         pmem->next = mem->next;
 107              		.loc 1 191 0
 108 005a 6268     		ldr	r2, [r4, #4]
 109 005c 5A60     		str	r2, [r3, #4]
 192:rt-thread/src/mem.c ****         ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
 110              		.loc 1 192 0
 111 005e 6268     		ldr	r2, [r4, #4]
 112 0060 0A44     		add	r2, r2, r1
 113 0062 5B1A     		subs	r3, r3, r1
 114              	.LVL5:
 115 0064 9360     		str	r3, [r2, #8]
 116              	.L1:
 117 0066 10BD     		pop	{r4, pc}
 118              	.LVL6:
 119              	.L10:
 161:rt-thread/src/mem.c ****     RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
 120              		.loc 1 161 0 discriminator 1
 121 0068 A122     		movs	r2, #161
 122 006a 0E49     		ldr	r1, .L15+12
 123 006c 0E48     		ldr	r0, .L15+16
 124              	.LVL7:
 125 006e FFF7FEFF 		bl	rt_assert_handler
 126              	.LVL8:
 127 0072 CBE7     		b	.L2
 128              	.L11:
 162:rt-thread/src/mem.c ****     RT_ASSERT(mem->used == 0);
 129              		.loc 1 162 0 discriminator 1
 130 0074 A222     		movs	r2, #162
 131 0076 0B49     		ldr	r1, .L15+12
 132 0078 0C48     		ldr	r0, .L15+20
 133 007a FFF7FEFF 		bl	rt_assert_handler
 134              	.LVL9:
 135 007e C9E7     		b	.L3
 136              	.L12:
 163:rt-thread/src/mem.c **** 
 137              		.loc 1 163 0 discriminator 1
 138 0080 A322     		movs	r2, #163
 139 0082 0849     		ldr	r1, .L15+12
 140 0084 0A48     		ldr	r0, .L15+24
 141 0086 FFF7FEFF 		bl	rt_assert_handler
 142              	.LVL10:
 143 008a C6E7     		b	.L4
 144              	.LVL11:
 145              	.L13:
 176:rt-thread/src/mem.c ****         }
ARM GAS  /tmp/cchS3cuE.s 			page 7


 146              		.loc 1 176 0
 147 008c 044B     		ldr	r3, .L15+8
 148 008e 1C60     		str	r4, [r3]
 149 0090 D3E7     		b	.L6
 150              	.LVL12:
 151              	.L14:
 189:rt-thread/src/mem.c ****         }
 152              		.loc 1 189 0
 153 0092 034A     		ldr	r2, .L15+8
 154 0094 1360     		str	r3, [r2]
 155 0096 E0E7     		b	.L8
 156              	.L16:
 157              		.align	2
 158              	.L15:
 159 0098 00000000 		.word	.LANCHOR0
 160 009c 00000000 		.word	.LANCHOR2
 161 00a0 00000000 		.word	.LANCHOR3
 162 00a4 00000000 		.word	.LANCHOR1
 163 00a8 00000000 		.word	.LC0
 164 00ac 20000000 		.word	.LC1
 165 00b0 4C000000 		.word	.LC2
 166              		.cfi_endproc
 167              	.LFE15:
 169              		.section	.text.rt_system_heap_init,"ax",%progbits
 170              		.align	1
 171              		.global	rt_system_heap_init
 172              		.syntax unified
 173              		.thumb
 174              		.thumb_func
 175              		.fpu fpv4-sp-d16
 177              	rt_system_heap_init:
 178              	.LFB16:
 193:rt-thread/src/mem.c ****     }
 194:rt-thread/src/mem.c **** }
 195:rt-thread/src/mem.c **** 
 196:rt-thread/src/mem.c **** /**
 197:rt-thread/src/mem.c ****  * @ingroup SystemInit
 198:rt-thread/src/mem.c ****  *
 199:rt-thread/src/mem.c ****  * This function will initialize system heap memory.
 200:rt-thread/src/mem.c ****  *
 201:rt-thread/src/mem.c ****  * @param begin_addr the beginning address of system heap memory.
 202:rt-thread/src/mem.c ****  * @param end_addr the end address of system heap memory.
 203:rt-thread/src/mem.c ****  */
 204:rt-thread/src/mem.c **** void rt_system_heap_init(void *begin_addr, void *end_addr)
 205:rt-thread/src/mem.c **** {
 179              		.loc 1 205 0
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 0, uses_anonymous_args = 0
 183              	.LVL13:
 184 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 185              	.LCFI1:
 186              		.cfi_def_cfa_offset 32
 187              		.cfi_offset 3, -32
 188              		.cfi_offset 4, -28
 189              		.cfi_offset 5, -24
 190              		.cfi_offset 6, -20
ARM GAS  /tmp/cchS3cuE.s 			page 8


 191              		.cfi_offset 7, -16
 192              		.cfi_offset 8, -12
 193              		.cfi_offset 9, -8
 194              		.cfi_offset 14, -4
 195 0004 0646     		mov	r6, r0
 196 0006 0F46     		mov	r7, r1
 206:rt-thread/src/mem.c ****     struct heap_mem *mem;
 207:rt-thread/src/mem.c ****     rt_ubase_t begin_align = RT_ALIGN((rt_ubase_t)begin_addr, RT_ALIGN_SIZE);
 197              		.loc 1 207 0
 198 0008 C41C     		adds	r4, r0, #3
 199 000a 24F00304 		bic	r4, r4, #3
 200              	.LVL14:
 208:rt-thread/src/mem.c ****     rt_ubase_t end_align   = RT_ALIGN_DOWN((rt_ubase_t)end_addr, RT_ALIGN_SIZE);
 201              		.loc 1 208 0
 202 000e 21F00305 		bic	r5, r1, #3
 203              	.LVL15:
 204              	.LBB2:
 209:rt-thread/src/mem.c **** 
 210:rt-thread/src/mem.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 205              		.loc 1 210 0
 206 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 207              	.LVL16:
 208 0016 8046     		mov	r8, r0
 209              	.LVL17:
 210 0018 FFF7FEFF 		bl	rt_interrupt_get_nest
 211              	.LVL18:
 212 001c 78B9     		cbnz	r0, .L22
 213              	.L18:
 214              		.loc 1 210 0 is_stmt 0 discriminator 5
 215 001e 4046     		mov	r0, r8
 216 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 217              	.LVL19:
 218              	.LBE2:
 211:rt-thread/src/mem.c **** 
 212:rt-thread/src/mem.c ****     /* alignment addr */
 213:rt-thread/src/mem.c ****     if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
 219              		.loc 1 213 0 is_stmt 1 discriminator 5
 220 0024 182D     		cmp	r5, #24
 221 0026 03D9     		bls	.L19
 214:rt-thread/src/mem.c ****         ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
 222              		.loc 1 214 0 discriminator 1
 223 0028 A5F11803 		sub	r3, r5, #24
 213:rt-thread/src/mem.c ****         ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
 224              		.loc 1 213 0 discriminator 1
 225 002c 9C42     		cmp	r4, r3
 226 002e 12D9     		bls	.L23
 227              	.L19:
 215:rt-thread/src/mem.c ****     {
 216:rt-thread/src/mem.c ****         /* calculate the aligned memory size */
 217:rt-thread/src/mem.c ****         mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
 218:rt-thread/src/mem.c ****     }
 219:rt-thread/src/mem.c ****     else
 220:rt-thread/src/mem.c ****     {
 221:rt-thread/src/mem.c ****         rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
 228              		.loc 1 221 0
 229 0030 3A46     		mov	r2, r7
 230 0032 3146     		mov	r1, r6
ARM GAS  /tmp/cchS3cuE.s 			page 9


 231 0034 1848     		ldr	r0, .L24
 232 0036 FFF7FEFF 		bl	rt_kprintf
 233              	.LVL20:
 234 003a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 235              	.LVL21:
 236              	.L22:
 237              	.LBB3:
 210:rt-thread/src/mem.c **** 
 238              		.loc 1 210 0 discriminator 1
 239 003e DFF87C90 		ldr	r9, .L24+36
 240 0042 4946     		mov	r1, r9
 241 0044 1548     		ldr	r0, .L24+4
 242 0046 FFF7FEFF 		bl	rt_kprintf
 243              	.LVL22:
 244 004a D222     		movs	r2, #210
 245 004c 4946     		mov	r1, r9
 246 004e 1448     		ldr	r0, .L24+8
 247 0050 FFF7FEFF 		bl	rt_assert_handler
 248              	.LVL23:
 249 0054 E3E7     		b	.L18
 250              	.L23:
 251              	.LBE3:
 217:rt-thread/src/mem.c ****     }
 252              		.loc 1 217 0
 253 0056 2D1B     		subs	r5, r5, r4
 254              	.LVL24:
 255 0058 A5F11802 		sub	r2, r5, #24
 256 005c 114B     		ldr	r3, .L24+12
 257              	.LVL25:
 258 005e 1A60     		str	r2, [r3]
 222:rt-thread/src/mem.c ****                    (rt_ubase_t)begin_addr, (rt_ubase_t)end_addr);
 223:rt-thread/src/mem.c **** 
 224:rt-thread/src/mem.c ****         return;
 225:rt-thread/src/mem.c ****     }
 226:rt-thread/src/mem.c **** 
 227:rt-thread/src/mem.c ****     /* point to begin address of heap */
 228:rt-thread/src/mem.c ****     heap_ptr = (rt_uint8_t *)begin_align;
 259              		.loc 1 228 0
 260 0060 114E     		ldr	r6, .L24+16
 261              	.LVL26:
 262 0062 3460     		str	r4, [r6]
 263              	.LVL27:
 229:rt-thread/src/mem.c **** 
 230:rt-thread/src/mem.c ****     RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
 231:rt-thread/src/mem.c ****                                 (rt_ubase_t)heap_ptr, mem_size_aligned));
 232:rt-thread/src/mem.c **** 
 233:rt-thread/src/mem.c ****     /* initialize the start of the heap */
 234:rt-thread/src/mem.c ****     mem        = (struct heap_mem *)heap_ptr;
 235:rt-thread/src/mem.c ****     mem->magic = HEAP_MAGIC;
 264              		.loc 1 235 0
 265 0064 4FF4F552 		mov	r2, #7840
 266 0068 2280     		strh	r2, [r4]	@ movhi
 236:rt-thread/src/mem.c ****     mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 267              		.loc 1 236 0
 268 006a 0C3D     		subs	r5, r5, #12
 269 006c 6560     		str	r5, [r4, #4]
 237:rt-thread/src/mem.c ****     mem->prev  = 0;
ARM GAS  /tmp/cchS3cuE.s 			page 10


 270              		.loc 1 237 0
 271 006e 0023     		movs	r3, #0
 272 0070 A360     		str	r3, [r4, #8]
 238:rt-thread/src/mem.c ****     mem->used  = 0;
 273              		.loc 1 238 0
 274 0072 6380     		strh	r3, [r4, #2]	@ movhi
 239:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 240:rt-thread/src/mem.c ****     rt_mem_setname(mem, "INIT");
 241:rt-thread/src/mem.c **** #endif
 242:rt-thread/src/mem.c **** 
 243:rt-thread/src/mem.c ****     /* initialize the end of the heap */
 244:rt-thread/src/mem.c ****     heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
 275              		.loc 1 244 0
 276 0074 6119     		adds	r1, r4, r5
 277 0076 0D48     		ldr	r0, .L24+20
 278 0078 0160     		str	r1, [r0]
 245:rt-thread/src/mem.c ****     heap_end->magic = HEAP_MAGIC;
 279              		.loc 1 245 0
 280 007a 6253     		strh	r2, [r4, r5]	@ movhi
 246:rt-thread/src/mem.c ****     heap_end->used  = 1;
 281              		.loc 1 246 0
 282 007c 0122     		movs	r2, #1
 283 007e 4A80     		strh	r2, [r1, #2]	@ movhi
 247:rt-thread/src/mem.c ****     heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 284              		.loc 1 247 0
 285 0080 4D60     		str	r5, [r1, #4]
 248:rt-thread/src/mem.c ****     heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
 286              		.loc 1 248 0
 287 0082 8D60     		str	r5, [r1, #8]
 249:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 250:rt-thread/src/mem.c ****     rt_mem_setname(heap_end, "INIT");
 251:rt-thread/src/mem.c **** #endif
 252:rt-thread/src/mem.c **** 
 253:rt-thread/src/mem.c ****     rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
 288              		.loc 1 253 0
 289 0084 0A49     		ldr	r1, .L24+24
 290 0086 0B48     		ldr	r0, .L24+28
 291 0088 FFF7FEFF 		bl	rt_sem_init
 292              	.LVL28:
 254:rt-thread/src/mem.c **** 
 255:rt-thread/src/mem.c ****     /* initialize the lowest-free pointer to the start of the heap */
 256:rt-thread/src/mem.c ****     lfree = (struct heap_mem *)heap_ptr;
 293              		.loc 1 256 0
 294 008c 3268     		ldr	r2, [r6]
 295 008e 0A4B     		ldr	r3, .L24+32
 296 0090 1A60     		str	r2, [r3]
 297 0092 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 298              	.LVL29:
 299              	.L25:
 300 0096 00BF     		.align	2
 301              	.L24:
 302 0098 34000000 		.word	.LC6
 303 009c 00000000 		.word	.LC3
 304 00a0 28000000 		.word	.LC4
 305 00a4 00000000 		.word	.LANCHOR5
 306 00a8 00000000 		.word	.LANCHOR0
 307 00ac 00000000 		.word	.LANCHOR2
ARM GAS  /tmp/cchS3cuE.s 			page 11


 308 00b0 2C000000 		.word	.LC5
 309 00b4 00000000 		.word	.LANCHOR6
 310 00b8 00000000 		.word	.LANCHOR3
 311 00bc 00000000 		.word	.LANCHOR4
 312              		.cfi_endproc
 313              	.LFE16:
 315              		.section	.text.rt_malloc,"ax",%progbits
 316              		.align	1
 317              		.global	rt_malloc
 318              		.syntax unified
 319              		.thumb
 320              		.thumb_func
 321              		.fpu fpv4-sp-d16
 323              	rt_malloc:
 324              	.LFB17:
 257:rt-thread/src/mem.c **** }
 258:rt-thread/src/mem.c **** 
 259:rt-thread/src/mem.c **** /**
 260:rt-thread/src/mem.c ****  * @addtogroup MM
 261:rt-thread/src/mem.c ****  */
 262:rt-thread/src/mem.c **** 
 263:rt-thread/src/mem.c **** /**@{*/
 264:rt-thread/src/mem.c **** 
 265:rt-thread/src/mem.c **** /**
 266:rt-thread/src/mem.c ****  * Allocate a block of memory with a minimum of 'size' bytes.
 267:rt-thread/src/mem.c ****  *
 268:rt-thread/src/mem.c ****  * @param size is the minimum size of the requested block in bytes.
 269:rt-thread/src/mem.c ****  *
 270:rt-thread/src/mem.c ****  * @return pointer to allocated memory or NULL if no free memory was found.
 271:rt-thread/src/mem.c ****  */
 272:rt-thread/src/mem.c **** void *rt_malloc(rt_size_t size)
 273:rt-thread/src/mem.c **** {
 325              		.loc 1 273 0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329              	.LVL30:
 274:rt-thread/src/mem.c ****     rt_size_t ptr, ptr2;
 275:rt-thread/src/mem.c ****     struct heap_mem *mem, *mem2;
 276:rt-thread/src/mem.c **** 
 277:rt-thread/src/mem.c ****     if (size == 0)
 330              		.loc 1 277 0
 331 0000 0028     		cmp	r0, #0
 332 0002 00F0BE80 		beq	.L42
 273:rt-thread/src/mem.c ****     rt_size_t ptr, ptr2;
 333              		.loc 1 273 0
 334 0006 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 335              	.LCFI2:
 336              		.cfi_def_cfa_offset 24
 337              		.cfi_offset 3, -24
 338              		.cfi_offset 4, -20
 339              		.cfi_offset 5, -16
 340              		.cfi_offset 6, -12
 341              		.cfi_offset 7, -8
 342              		.cfi_offset 14, -4
 343 0008 0546     		mov	r5, r0
 344              	.LBB4:
ARM GAS  /tmp/cchS3cuE.s 			page 12


 278:rt-thread/src/mem.c ****         return RT_NULL;
 279:rt-thread/src/mem.c **** 
 280:rt-thread/src/mem.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 345              		.loc 1 280 0
 346 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 347              	.LVL31:
 348 000e 0446     		mov	r4, r0
 349              	.LVL32:
 350 0010 FFF7FEFF 		bl	rt_interrupt_get_nest
 351              	.LVL33:
 352 0014 C0B9     		cbnz	r0, .L50
 353              	.L28:
 354              		.loc 1 280 0 is_stmt 0 discriminator 5
 355 0016 2046     		mov	r0, r4
 356 0018 FFF7FEFF 		bl	rt_hw_interrupt_enable
 357              	.LVL34:
 358              	.LBE4:
 281:rt-thread/src/mem.c **** 
 282:rt-thread/src/mem.c ****     if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
 359              		.loc 1 282 0 is_stmt 1 discriminator 5
 360 001c 0335     		adds	r5, r5, #3
 361              	.LVL35:
 362 001e 25F00305 		bic	r5, r5, #3
 363              	.LVL36:
 283:rt-thread/src/mem.c ****         RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
 284:rt-thread/src/mem.c ****                                     size, RT_ALIGN(size, RT_ALIGN_SIZE)));
 285:rt-thread/src/mem.c ****     else
 286:rt-thread/src/mem.c ****         RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
 287:rt-thread/src/mem.c **** 
 288:rt-thread/src/mem.c ****     /* alignment size */
 289:rt-thread/src/mem.c ****     size = RT_ALIGN(size, RT_ALIGN_SIZE);
 290:rt-thread/src/mem.c **** 
 291:rt-thread/src/mem.c ****     if (size > mem_size_aligned)
 364              		.loc 1 291 0 discriminator 5
 365 0022 5A4B     		ldr	r3, .L55
 366 0024 1B68     		ldr	r3, [r3]
 367 0026 9D42     		cmp	r5, r3
 368 0028 00F2AD80 		bhi	.L43
 292:rt-thread/src/mem.c ****     {
 293:rt-thread/src/mem.c ****         RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));
 294:rt-thread/src/mem.c **** 
 295:rt-thread/src/mem.c ****         return RT_NULL;
 296:rt-thread/src/mem.c ****     }
 297:rt-thread/src/mem.c **** 
 298:rt-thread/src/mem.c ****     /* every data block must be at least MIN_SIZE_ALIGNED long */
 299:rt-thread/src/mem.c ****     if (size < MIN_SIZE_ALIGNED)
 369              		.loc 1 299 0
 370 002c 0B2D     		cmp	r5, #11
 371 002e 00D8     		bhi	.L29
 300:rt-thread/src/mem.c ****         size = MIN_SIZE_ALIGNED;
 372              		.loc 1 300 0
 373 0030 0C25     		movs	r5, #12
 374              	.LVL37:
 375              	.L29:
 301:rt-thread/src/mem.c **** 
 302:rt-thread/src/mem.c ****     /* take memory semaphore */
 303:rt-thread/src/mem.c ****     rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
ARM GAS  /tmp/cchS3cuE.s 			page 13


 376              		.loc 1 303 0
 377 0032 4FF0FF31 		mov	r1, #-1
 378 0036 5648     		ldr	r0, .L55+4
 379 0038 FFF7FEFF 		bl	rt_sem_take
 380              	.LVL38:
 304:rt-thread/src/mem.c **** 
 305:rt-thread/src/mem.c ****     for (ptr = (rt_uint8_t *)lfree - heap_ptr;
 381              		.loc 1 305 0
 382 003c 554B     		ldr	r3, .L55+8
 383 003e 1E68     		ldr	r6, [r3]
 384 0040 554B     		ldr	r3, .L55+12
 385 0042 1B68     		ldr	r3, [r3]
 386 0044 9B1B     		subs	r3, r3, r6
 387              	.LVL39:
 388 0046 4CE0     		b	.L30
 389              	.LVL40:
 390              	.L50:
 391              	.LBB5:
 280:rt-thread/src/mem.c **** 
 392              		.loc 1 280 0 discriminator 1
 393 0048 544E     		ldr	r6, .L55+16
 394 004a 3146     		mov	r1, r6
 395 004c 5448     		ldr	r0, .L55+20
 396 004e FFF7FEFF 		bl	rt_kprintf
 397              	.LVL41:
 398 0052 4FF48C72 		mov	r2, #280
 399 0056 3146     		mov	r1, r6
 400 0058 5248     		ldr	r0, .L55+24
 401 005a FFF7FEFF 		bl	rt_assert_handler
 402              	.LVL42:
 403 005e DAE7     		b	.L28
 404              	.LVL43:
 405              	.L32:
 406              	.LBE5:
 306:rt-thread/src/mem.c ****          ptr < mem_size_aligned - size;
 307:rt-thread/src/mem.c ****          ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
 308:rt-thread/src/mem.c ****     {
 309:rt-thread/src/mem.c ****         mem = (struct heap_mem *)&heap_ptr[ptr];
 310:rt-thread/src/mem.c **** 
 311:rt-thread/src/mem.c ****         if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
 312:rt-thread/src/mem.c ****         {
 313:rt-thread/src/mem.c ****             /* mem is not used and at least perfect fit is possible:
 314:rt-thread/src/mem.c ****              * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
 315:rt-thread/src/mem.c **** 
 316:rt-thread/src/mem.c ****             if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
 317:rt-thread/src/mem.c ****                 (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 318:rt-thread/src/mem.c ****             {
 319:rt-thread/src/mem.c ****                 /* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM
 320:rt-thread/src/mem.c ****                  * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
 321:rt-thread/src/mem.c ****                  * -> split large block, create empty remainder,
 322:rt-thread/src/mem.c ****                  * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
 323:rt-thread/src/mem.c ****                  * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
 324:rt-thread/src/mem.c ****                  * struct heap_mem would fit in but no data between mem2 and mem2->next
 325:rt-thread/src/mem.c ****                  * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
 326:rt-thread/src/mem.c ****                  *       region that couldn't hold data, but when mem->next gets freed,
 327:rt-thread/src/mem.c ****                  *       the 2 regions would be combined, resulting in more free memory
 328:rt-thread/src/mem.c ****                  */
ARM GAS  /tmp/cchS3cuE.s 			page 14


 329:rt-thread/src/mem.c ****                 ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 330:rt-thread/src/mem.c **** 
 331:rt-thread/src/mem.c ****                 /* create mem2 struct */
 332:rt-thread/src/mem.c ****                 mem2       = (struct heap_mem *)&heap_ptr[ptr2];
 333:rt-thread/src/mem.c ****                 mem2->magic = HEAP_MAGIC;
 334:rt-thread/src/mem.c ****                 mem2->used = 0;
 335:rt-thread/src/mem.c ****                 mem2->next = mem->next;
 336:rt-thread/src/mem.c ****                 mem2->prev = ptr;
 337:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 338:rt-thread/src/mem.c ****                 rt_mem_setname(mem2, "    ");
 339:rt-thread/src/mem.c **** #endif
 340:rt-thread/src/mem.c **** 
 341:rt-thread/src/mem.c ****                 /* and insert it between mem and mem->next */
 342:rt-thread/src/mem.c ****                 mem->next = ptr2;
 343:rt-thread/src/mem.c ****                 mem->used = 1;
 344:rt-thread/src/mem.c **** 
 345:rt-thread/src/mem.c ****                 if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 346:rt-thread/src/mem.c ****                 {
 347:rt-thread/src/mem.c ****                     ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
 348:rt-thread/src/mem.c ****                 }
 349:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 350:rt-thread/src/mem.c ****                 used_mem += (size + SIZEOF_STRUCT_MEM);
 351:rt-thread/src/mem.c ****                 if (max_mem < used_mem)
 352:rt-thread/src/mem.c ****                     max_mem = used_mem;
 353:rt-thread/src/mem.c **** #endif
 354:rt-thread/src/mem.c ****             }
 355:rt-thread/src/mem.c ****             else
 356:rt-thread/src/mem.c ****             {
 357:rt-thread/src/mem.c ****                 /* (a mem2 struct does no fit into the user data space of mem and mem->next will al
 358:rt-thread/src/mem.c ****                  * be used at this point: if not we have 2 unused structs in a row, plug_holes shou
 359:rt-thread/src/mem.c ****                  * take care of this).
 360:rt-thread/src/mem.c ****                  * -> near fit or excact fit: do not split, no mem2 creation
 361:rt-thread/src/mem.c ****                  * also can't move mem->next directly behind mem, since mem->next
 362:rt-thread/src/mem.c ****                  * will always be used at this point!
 363:rt-thread/src/mem.c ****                  */
 364:rt-thread/src/mem.c ****                 mem->used = 1;
 407              		.loc 1 364 0
 408 0060 0123     		movs	r3, #1
 409              	.LVL44:
 410 0062 6380     		strh	r3, [r4, #2]	@ movhi
 365:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 366:rt-thread/src/mem.c ****                 used_mem += mem->next - ((rt_uint8_t *)mem - heap_ptr);
 411              		.loc 1 366 0
 412 0064 A31B     		subs	r3, r4, r6
 413 0066 C31A     		subs	r3, r0, r3
 414 0068 4F4A     		ldr	r2, .L55+28
 415 006a 1168     		ldr	r1, [r2]
 416 006c 0B44     		add	r3, r3, r1
 417 006e 1360     		str	r3, [r2]
 367:rt-thread/src/mem.c ****                 if (max_mem < used_mem)
 418              		.loc 1 367 0
 419 0070 4E4A     		ldr	r2, .L55+32
 420 0072 1268     		ldr	r2, [r2]
 421 0074 9342     		cmp	r3, r2
 422 0076 65D9     		bls	.L34
 368:rt-thread/src/mem.c ****                     max_mem = used_mem;
 423              		.loc 1 368 0
ARM GAS  /tmp/cchS3cuE.s 			page 15


 424 0078 4C4A     		ldr	r2, .L55+32
 425 007a 1360     		str	r3, [r2]
 426 007c 62E0     		b	.L34
 427              	.L38:
 369:rt-thread/src/mem.c **** #endif
 370:rt-thread/src/mem.c ****             }
 371:rt-thread/src/mem.c ****             /* set memory block magic */
 372:rt-thread/src/mem.c ****             mem->magic = HEAP_MAGIC;
 373:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 374:rt-thread/src/mem.c ****             if (rt_thread_self())
 375:rt-thread/src/mem.c ****                 rt_mem_setname(mem, rt_thread_self()->name);
 376:rt-thread/src/mem.c ****             else
 377:rt-thread/src/mem.c ****                 rt_mem_setname(mem, "NONE");
 378:rt-thread/src/mem.c **** #endif
 379:rt-thread/src/mem.c **** 
 380:rt-thread/src/mem.c ****             if (mem == lfree)
 381:rt-thread/src/mem.c ****             {
 382:rt-thread/src/mem.c ****                 /* Find next free block after mem and update lowest free pointer */
 383:rt-thread/src/mem.c ****                 while (lfree->used && lfree != heap_end)
 384:rt-thread/src/mem.c ****                     lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 428              		.loc 1 384 0
 429 007e 5A68     		ldr	r2, [r3, #4]
 430 0080 444B     		ldr	r3, .L55+8
 431 0082 1B68     		ldr	r3, [r3]
 432 0084 1344     		add	r3, r3, r2
 433 0086 444A     		ldr	r2, .L55+12
 434 0088 1360     		str	r3, [r2]
 435              	.L35:
 383:rt-thread/src/mem.c ****                     lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 436              		.loc 1 383 0
 437 008a 434B     		ldr	r3, .L55+12
 438 008c 1B68     		ldr	r3, [r3]
 439 008e 5A88     		ldrh	r2, [r3, #2]
 440 0090 1AB1     		cbz	r2, .L37
 383:rt-thread/src/mem.c ****                     lfree = (struct heap_mem *)&heap_ptr[lfree->next];
 441              		.loc 1 383 0 is_stmt 0 discriminator 1
 442 0092 4749     		ldr	r1, .L55+36
 443 0094 0968     		ldr	r1, [r1]
 444 0096 8B42     		cmp	r3, r1
 445 0098 F1D1     		bne	.L38
 446              	.L37:
 385:rt-thread/src/mem.c **** 
 386:rt-thread/src/mem.c ****                 RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
 447              		.loc 1 386 0 is_stmt 1
 448 009a 4549     		ldr	r1, .L55+36
 449 009c 0968     		ldr	r1, [r1]
 450 009e 8B42     		cmp	r3, r1
 451 00a0 57D0     		beq	.L36
 452              		.loc 1 386 0 is_stmt 0 discriminator 1
 453 00a2 002A     		cmp	r2, #0
 454 00a4 55D0     		beq	.L36
 455              		.loc 1 386 0 discriminator 2
 456 00a6 4FF4C172 		mov	r2, #386
 457 00aa 3C49     		ldr	r1, .L55+16
 458 00ac 4148     		ldr	r0, .L55+40
 459 00ae FFF7FEFF 		bl	rt_assert_handler
 460              	.LVL45:
ARM GAS  /tmp/cchS3cuE.s 			page 16


 461 00b2 4EE0     		b	.L36
 462              	.LVL46:
 463              	.L52:
 387:rt-thread/src/mem.c ****             }
 388:rt-thread/src/mem.c **** 
 389:rt-thread/src/mem.c ****             rt_sem_release(&heap_sem);
 390:rt-thread/src/mem.c ****             RT_ASSERT((rt_ubase_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_ubase_t)heap_end);
 464              		.loc 1 390 0 is_stmt 1 discriminator 1
 465 00b4 4FF4C372 		mov	r2, #390
 466 00b8 3849     		ldr	r1, .L55+16
 467 00ba 3F48     		ldr	r0, .L55+44
 468 00bc FFF7FEFF 		bl	rt_assert_handler
 469              	.LVL47:
 470 00c0 50E0     		b	.L39
 471              	.L53:
 391:rt-thread/src/mem.c ****             RT_ASSERT((rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
 472              		.loc 1 391 0 discriminator 1
 473 00c2 40F28712 		movw	r2, #391
 474 00c6 3549     		ldr	r1, .L55+16
 475 00c8 3C48     		ldr	r0, .L55+48
 476 00ca FFF7FEFF 		bl	rt_assert_handler
 477              	.LVL48:
 478 00ce 4EE0     		b	.L40
 479              	.L54:
 392:rt-thread/src/mem.c ****             RT_ASSERT((((rt_ubase_t)mem) & (RT_ALIGN_SIZE - 1)) == 0);
 480              		.loc 1 392 0 discriminator 1
 481 00d0 4FF4C472 		mov	r2, #392
 482 00d4 3149     		ldr	r1, .L55+16
 483 00d6 3A48     		ldr	r0, .L55+52
 484 00d8 FFF7FEFF 		bl	rt_assert_handler
 485              	.LVL49:
 393:rt-thread/src/mem.c **** 
 394:rt-thread/src/mem.c ****             RT_DEBUG_LOG(RT_DEBUG_MEM,
 395:rt-thread/src/mem.c ****                          ("allocate memory at 0x%x, size: %d\n",
 396:rt-thread/src/mem.c ****                           (rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
 397:rt-thread/src/mem.c ****                           (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
 398:rt-thread/src/mem.c **** 
 399:rt-thread/src/mem.c ****             RT_OBJECT_HOOK_CALL(rt_malloc_hook,
 400:rt-thread/src/mem.c ****                                 (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
 401:rt-thread/src/mem.c **** 
 402:rt-thread/src/mem.c ****             /* return the memory data except mem struct */
 403:rt-thread/src/mem.c ****             return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
 486              		.loc 1 403 0 discriminator 1
 487 00dc 2846     		mov	r0, r5
 488 00de F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 489              	.LVL50:
 490              	.L31:
 307:rt-thread/src/mem.c ****     {
 491              		.loc 1 307 0
 492 00e0 6368     		ldr	r3, [r4, #4]
 493              	.LVL51:
 494              	.L30:
 306:rt-thread/src/mem.c ****          ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
 495              		.loc 1 306 0 discriminator 1
 496 00e2 2A4A     		ldr	r2, .L55
 497 00e4 1268     		ldr	r2, [r2]
 498 00e6 511B     		subs	r1, r2, r5
ARM GAS  /tmp/cchS3cuE.s 			page 17


 305:rt-thread/src/mem.c ****          ptr < mem_size_aligned - size;
 499              		.loc 1 305 0 discriminator 1
 500 00e8 8B42     		cmp	r3, r1
 501 00ea 45D2     		bcs	.L51
 309:rt-thread/src/mem.c **** 
 502              		.loc 1 309 0
 503 00ec F418     		adds	r4, r6, r3
 504              	.LVL52:
 311:rt-thread/src/mem.c ****         {
 505              		.loc 1 311 0
 506 00ee 6188     		ldrh	r1, [r4, #2]
 507 00f0 0029     		cmp	r1, #0
 508 00f2 F5D1     		bne	.L31
 311:rt-thread/src/mem.c ****         {
 509              		.loc 1 311 0 is_stmt 0 discriminator 1
 510 00f4 6068     		ldr	r0, [r4, #4]
 511 00f6 C11A     		subs	r1, r0, r3
 512 00f8 0C39     		subs	r1, r1, #12
 513 00fa 8D42     		cmp	r5, r1
 514 00fc F0D8     		bhi	.L31
 317:rt-thread/src/mem.c ****             {
 515              		.loc 1 317 0 is_stmt 1
 516 00fe 05F11807 		add	r7, r5, #24
 316:rt-thread/src/mem.c ****                 (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
 517              		.loc 1 316 0
 518 0102 B942     		cmp	r1, r7
 519 0104 ACD3     		bcc	.L32
 329:rt-thread/src/mem.c **** 
 520              		.loc 1 329 0
 521 0106 E918     		adds	r1, r5, r3
 522 0108 0C31     		adds	r1, r1, #12
 523              	.LVL53:
 332:rt-thread/src/mem.c ****                 mem2->magic = HEAP_MAGIC;
 524              		.loc 1 332 0
 525 010a 7018     		adds	r0, r6, r1
 526              	.LVL54:
 333:rt-thread/src/mem.c ****                 mem2->used = 0;
 527              		.loc 1 333 0
 528 010c 4FF4F557 		mov	r7, #7840
 529 0110 7752     		strh	r7, [r6, r1]	@ movhi
 334:rt-thread/src/mem.c ****                 mem2->next = mem->next;
 530              		.loc 1 334 0
 531 0112 0027     		movs	r7, #0
 532 0114 4780     		strh	r7, [r0, #2]	@ movhi
 335:rt-thread/src/mem.c ****                 mem2->prev = ptr;
 533              		.loc 1 335 0
 534 0116 6768     		ldr	r7, [r4, #4]
 535 0118 4760     		str	r7, [r0, #4]
 336:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 536              		.loc 1 336 0
 537 011a 8360     		str	r3, [r0, #8]
 342:rt-thread/src/mem.c ****                 mem->used = 1;
 538              		.loc 1 342 0
 539 011c 6160     		str	r1, [r4, #4]
 343:rt-thread/src/mem.c **** 
 540              		.loc 1 343 0
 541 011e 0123     		movs	r3, #1
ARM GAS  /tmp/cchS3cuE.s 			page 18


 542              	.LVL55:
 543 0120 6380     		strh	r3, [r4, #2]	@ movhi
 345:rt-thread/src/mem.c ****                 {
 544              		.loc 1 345 0
 545 0122 4368     		ldr	r3, [r0, #4]
 546 0124 0C32     		adds	r2, r2, #12
 547 0126 9342     		cmp	r3, r2
 548 0128 01D0     		beq	.L33
 347:rt-thread/src/mem.c ****                 }
 549              		.loc 1 347 0
 550 012a 3344     		add	r3, r3, r6
 551 012c 9960     		str	r1, [r3, #8]
 552              	.L33:
 350:rt-thread/src/mem.c ****                 if (max_mem < used_mem)
 553              		.loc 1 350 0
 554 012e 1E4A     		ldr	r2, .L55+28
 555 0130 1368     		ldr	r3, [r2]
 556 0132 2B44     		add	r3, r3, r5
 557 0134 0C33     		adds	r3, r3, #12
 558 0136 1360     		str	r3, [r2]
 351:rt-thread/src/mem.c ****                     max_mem = used_mem;
 559              		.loc 1 351 0
 560 0138 1C4A     		ldr	r2, .L55+32
 561 013a 1268     		ldr	r2, [r2]
 562 013c 9342     		cmp	r3, r2
 563 013e 01D9     		bls	.L34
 352:rt-thread/src/mem.c **** #endif
 564              		.loc 1 352 0
 565 0140 1A4A     		ldr	r2, .L55+32
 566 0142 1360     		str	r3, [r2]
 567              	.LVL56:
 568              	.L34:
 372:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 569              		.loc 1 372 0
 570 0144 4FF4F553 		mov	r3, #7840
 571 0148 2380     		strh	r3, [r4]	@ movhi
 380:rt-thread/src/mem.c ****             {
 572              		.loc 1 380 0
 573 014a 134B     		ldr	r3, .L55+12
 574 014c 1B68     		ldr	r3, [r3]
 575 014e 9C42     		cmp	r4, r3
 576 0150 9BD0     		beq	.L35
 577              	.L36:
 389:rt-thread/src/mem.c ****             RT_ASSERT((rt_ubase_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_ubase_t)heap_end);
 578              		.loc 1 389 0
 579 0152 0F48     		ldr	r0, .L55+4
 580 0154 FFF7FEFF 		bl	rt_sem_release
 581              	.LVL57:
 390:rt-thread/src/mem.c ****             RT_ASSERT((rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
 582              		.loc 1 390 0
 583 0158 2544     		add	r5, r5, r4
 584              	.LVL58:
 585 015a 0C35     		adds	r5, r5, #12
 586 015c 144B     		ldr	r3, .L55+36
 587 015e 1B68     		ldr	r3, [r3]
 588 0160 9D42     		cmp	r5, r3
 589 0162 A7D8     		bhi	.L52
ARM GAS  /tmp/cchS3cuE.s 			page 19


 590              	.L39:
 391:rt-thread/src/mem.c ****             RT_ASSERT((((rt_ubase_t)mem) & (RT_ALIGN_SIZE - 1)) == 0);
 591              		.loc 1 391 0
 592 0164 04F10C05 		add	r5, r4, #12
 593 0168 15F0030F 		tst	r5, #3
 594 016c A9D1     		bne	.L53
 595              	.L40:
 392:rt-thread/src/mem.c **** 
 596              		.loc 1 392 0
 597 016e 14F0030F 		tst	r4, #3
 598 0172 ADD1     		bne	.L54
 599              		.loc 1 403 0
 600 0174 2846     		mov	r0, r5
 404:rt-thread/src/mem.c ****         }
 405:rt-thread/src/mem.c ****     }
 406:rt-thread/src/mem.c **** 
 407:rt-thread/src/mem.c ****     rt_sem_release(&heap_sem);
 408:rt-thread/src/mem.c **** 
 409:rt-thread/src/mem.c ****     return RT_NULL;
 410:rt-thread/src/mem.c **** }
 601              		.loc 1 410 0
 602 0176 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 603              	.LVL59:
 604              	.L51:
 407:rt-thread/src/mem.c **** 
 605              		.loc 1 407 0
 606 0178 0548     		ldr	r0, .L55+4
 607 017a FFF7FEFF 		bl	rt_sem_release
 608              	.LVL60:
 409:rt-thread/src/mem.c **** }
 609              		.loc 1 409 0
 610 017e 0020     		movs	r0, #0
 611 0180 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 612              	.LVL61:
 613              	.L42:
 614              	.LCFI3:
 615              		.cfi_def_cfa_offset 0
 616              		.cfi_restore 3
 617              		.cfi_restore 4
 618              		.cfi_restore 5
 619              		.cfi_restore 6
 620              		.cfi_restore 7
 621              		.cfi_restore 14
 278:rt-thread/src/mem.c **** 
 622              		.loc 1 278 0
 623 0182 0020     		movs	r0, #0
 624              	.LVL62:
 625 0184 7047     		bx	lr
 626              	.LVL63:
 627              	.L43:
 628              	.LCFI4:
 629              		.cfi_def_cfa_offset 24
 630              		.cfi_offset 3, -24
 631              		.cfi_offset 4, -20
 632              		.cfi_offset 5, -16
 633              		.cfi_offset 6, -12
 634              		.cfi_offset 7, -8
ARM GAS  /tmp/cchS3cuE.s 			page 20


 635              		.cfi_offset 14, -4
 295:rt-thread/src/mem.c ****     }
 636              		.loc 1 295 0
 637 0186 0020     		movs	r0, #0
 638 0188 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 639              	.LVL64:
 640              	.L56:
 641 018a 00BF     		.align	2
 642              	.L55:
 643 018c 00000000 		.word	.LANCHOR5
 644 0190 00000000 		.word	.LANCHOR6
 645 0194 00000000 		.word	.LANCHOR0
 646 0198 00000000 		.word	.LANCHOR3
 647 019c 00000000 		.word	.LANCHOR7
 648 01a0 00000000 		.word	.LC3
 649 01a4 28000000 		.word	.LC4
 650 01a8 00000000 		.word	.LANCHOR8
 651 01ac 00000000 		.word	.LANCHOR9
 652 01b0 00000000 		.word	.LANCHOR2
 653 01b4 00000000 		.word	.LC7
 654 01b8 28000000 		.word	.LC8
 655 01bc 6C000000 		.word	.LC9
 656 01c0 B8000000 		.word	.LC10
 657              		.cfi_endproc
 658              	.LFE17:
 660              		.section	.text.rt_calloc,"ax",%progbits
 661              		.align	1
 662              		.global	rt_calloc
 663              		.syntax unified
 664              		.thumb
 665              		.thumb_func
 666              		.fpu fpv4-sp-d16
 668              	rt_calloc:
 669              	.LFB19:
 411:rt-thread/src/mem.c **** RTM_EXPORT(rt_malloc);
 412:rt-thread/src/mem.c **** 
 413:rt-thread/src/mem.c **** /**
 414:rt-thread/src/mem.c ****  * This function will change the previously allocated memory block.
 415:rt-thread/src/mem.c ****  *
 416:rt-thread/src/mem.c ****  * @param rmem pointer to memory allocated by rt_malloc
 417:rt-thread/src/mem.c ****  * @param newsize the required new size
 418:rt-thread/src/mem.c ****  *
 419:rt-thread/src/mem.c ****  * @return the changed memory block address
 420:rt-thread/src/mem.c ****  */
 421:rt-thread/src/mem.c **** void *rt_realloc(void *rmem, rt_size_t newsize)
 422:rt-thread/src/mem.c **** {
 423:rt-thread/src/mem.c ****     rt_size_t size;
 424:rt-thread/src/mem.c ****     rt_size_t ptr, ptr2;
 425:rt-thread/src/mem.c ****     struct heap_mem *mem, *mem2;
 426:rt-thread/src/mem.c ****     void *nmem;
 427:rt-thread/src/mem.c **** 
 428:rt-thread/src/mem.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 429:rt-thread/src/mem.c **** 
 430:rt-thread/src/mem.c ****     /* alignment size */
 431:rt-thread/src/mem.c ****     newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
 432:rt-thread/src/mem.c ****     if (newsize > mem_size_aligned)
 433:rt-thread/src/mem.c ****     {
ARM GAS  /tmp/cchS3cuE.s 			page 21


 434:rt-thread/src/mem.c ****         RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));
 435:rt-thread/src/mem.c **** 
 436:rt-thread/src/mem.c ****         return RT_NULL;
 437:rt-thread/src/mem.c ****     }
 438:rt-thread/src/mem.c ****     else if (newsize == 0)
 439:rt-thread/src/mem.c ****     {
 440:rt-thread/src/mem.c ****         rt_free(rmem);
 441:rt-thread/src/mem.c ****         return RT_NULL;
 442:rt-thread/src/mem.c ****     }
 443:rt-thread/src/mem.c **** 
 444:rt-thread/src/mem.c ****     /* allocate a new memory block */
 445:rt-thread/src/mem.c ****     if (rmem == RT_NULL)
 446:rt-thread/src/mem.c ****         return rt_malloc(newsize);
 447:rt-thread/src/mem.c **** 
 448:rt-thread/src/mem.c ****     rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 449:rt-thread/src/mem.c **** 
 450:rt-thread/src/mem.c ****     if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 451:rt-thread/src/mem.c ****         (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 452:rt-thread/src/mem.c ****     {
 453:rt-thread/src/mem.c ****         /* illegal memory */
 454:rt-thread/src/mem.c ****         rt_sem_release(&heap_sem);
 455:rt-thread/src/mem.c **** 
 456:rt-thread/src/mem.c ****         return rmem;
 457:rt-thread/src/mem.c ****     }
 458:rt-thread/src/mem.c **** 
 459:rt-thread/src/mem.c ****     mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 460:rt-thread/src/mem.c **** 
 461:rt-thread/src/mem.c ****     ptr = (rt_uint8_t *)mem - heap_ptr;
 462:rt-thread/src/mem.c ****     size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 463:rt-thread/src/mem.c ****     if (size == newsize)
 464:rt-thread/src/mem.c ****     {
 465:rt-thread/src/mem.c ****         /* the size is the same as */
 466:rt-thread/src/mem.c ****         rt_sem_release(&heap_sem);
 467:rt-thread/src/mem.c **** 
 468:rt-thread/src/mem.c ****         return rmem;
 469:rt-thread/src/mem.c ****     }
 470:rt-thread/src/mem.c **** 
 471:rt-thread/src/mem.c ****     if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
 472:rt-thread/src/mem.c ****     {
 473:rt-thread/src/mem.c ****         /* split memory block */
 474:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 475:rt-thread/src/mem.c ****         used_mem -= (size - newsize);
 476:rt-thread/src/mem.c **** #endif
 477:rt-thread/src/mem.c **** 
 478:rt-thread/src/mem.c ****         ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 479:rt-thread/src/mem.c ****         mem2 = (struct heap_mem *)&heap_ptr[ptr2];
 480:rt-thread/src/mem.c ****         mem2->magic = HEAP_MAGIC;
 481:rt-thread/src/mem.c ****         mem2->used = 0;
 482:rt-thread/src/mem.c ****         mem2->next = mem->next;
 483:rt-thread/src/mem.c ****         mem2->prev = ptr;
 484:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 485:rt-thread/src/mem.c ****         rt_mem_setname(mem2, "    ");
 486:rt-thread/src/mem.c **** #endif
 487:rt-thread/src/mem.c ****         mem->next = ptr2;
 488:rt-thread/src/mem.c ****         if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
 489:rt-thread/src/mem.c ****         {
 490:rt-thread/src/mem.c ****             ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
ARM GAS  /tmp/cchS3cuE.s 			page 22


 491:rt-thread/src/mem.c ****         }
 492:rt-thread/src/mem.c **** 
 493:rt-thread/src/mem.c ****         plug_holes(mem2);
 494:rt-thread/src/mem.c **** 
 495:rt-thread/src/mem.c ****         rt_sem_release(&heap_sem);
 496:rt-thread/src/mem.c **** 
 497:rt-thread/src/mem.c ****         return rmem;
 498:rt-thread/src/mem.c ****     }
 499:rt-thread/src/mem.c ****     rt_sem_release(&heap_sem);
 500:rt-thread/src/mem.c **** 
 501:rt-thread/src/mem.c ****     /* expand memory */
 502:rt-thread/src/mem.c ****     nmem = rt_malloc(newsize);
 503:rt-thread/src/mem.c ****     if (nmem != RT_NULL) /* check memory */
 504:rt-thread/src/mem.c ****     {
 505:rt-thread/src/mem.c ****         rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
 506:rt-thread/src/mem.c ****         rt_free(rmem);
 507:rt-thread/src/mem.c ****     }
 508:rt-thread/src/mem.c **** 
 509:rt-thread/src/mem.c ****     return nmem;
 510:rt-thread/src/mem.c **** }
 511:rt-thread/src/mem.c **** RTM_EXPORT(rt_realloc);
 512:rt-thread/src/mem.c **** 
 513:rt-thread/src/mem.c **** /**
 514:rt-thread/src/mem.c ****  * This function will contiguously allocate enough space for count objects
 515:rt-thread/src/mem.c ****  * that are size bytes of memory each and returns a pointer to the allocated
 516:rt-thread/src/mem.c ****  * memory.
 517:rt-thread/src/mem.c ****  *
 518:rt-thread/src/mem.c ****  * The allocated memory is filled with bytes of value zero.
 519:rt-thread/src/mem.c ****  *
 520:rt-thread/src/mem.c ****  * @param count number of objects to allocate
 521:rt-thread/src/mem.c ****  * @param size size of the objects to allocate
 522:rt-thread/src/mem.c ****  *
 523:rt-thread/src/mem.c ****  * @return pointer to allocated memory / NULL pointer if there is an error
 524:rt-thread/src/mem.c ****  */
 525:rt-thread/src/mem.c **** void *rt_calloc(rt_size_t count, rt_size_t size)
 526:rt-thread/src/mem.c **** {
 670              		.loc 1 526 0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 0
 673              		@ frame_needed = 0, uses_anonymous_args = 0
 674              	.LVL65:
 675 0000 38B5     		push	{r3, r4, r5, lr}
 676              	.LCFI5:
 677              		.cfi_def_cfa_offset 16
 678              		.cfi_offset 3, -16
 679              		.cfi_offset 4, -12
 680              		.cfi_offset 5, -8
 681              		.cfi_offset 14, -4
 527:rt-thread/src/mem.c ****     void *p;
 528:rt-thread/src/mem.c **** 
 529:rt-thread/src/mem.c ****     /* allocate 'count' objects of size 'size' */
 530:rt-thread/src/mem.c ****     p = rt_malloc(count * size);
 682              		.loc 1 530 0
 683 0002 01FB00F5 		mul	r5, r1, r0
 684 0006 2846     		mov	r0, r5
 685              	.LVL66:
 686 0008 FFF7FEFF 		bl	rt_malloc
ARM GAS  /tmp/cchS3cuE.s 			page 23


 687              	.LVL67:
 531:rt-thread/src/mem.c **** 
 532:rt-thread/src/mem.c ****     /* zero the memory */
 533:rt-thread/src/mem.c ****     if (p)
 688              		.loc 1 533 0
 689 000c 0446     		mov	r4, r0
 690 000e 18B1     		cbz	r0, .L57
 534:rt-thread/src/mem.c ****         rt_memset(p, 0, count * size);
 691              		.loc 1 534 0
 692 0010 2A46     		mov	r2, r5
 693 0012 0021     		movs	r1, #0
 694 0014 FFF7FEFF 		bl	rt_memset
 695              	.LVL68:
 696              	.L57:
 535:rt-thread/src/mem.c **** 
 536:rt-thread/src/mem.c ****     return p;
 537:rt-thread/src/mem.c **** }
 697              		.loc 1 537 0
 698 0018 2046     		mov	r0, r4
 699 001a 38BD     		pop	{r3, r4, r5, pc}
 700              		.cfi_endproc
 701              	.LFE19:
 703              		.section	.text.rt_free,"ax",%progbits
 704              		.align	1
 705              		.global	rt_free
 706              		.syntax unified
 707              		.thumb
 708              		.thumb_func
 709              		.fpu fpv4-sp-d16
 711              	rt_free:
 712              	.LFB20:
 538:rt-thread/src/mem.c **** RTM_EXPORT(rt_calloc);
 539:rt-thread/src/mem.c **** 
 540:rt-thread/src/mem.c **** /**
 541:rt-thread/src/mem.c ****  * This function will release the previously allocated memory block by
 542:rt-thread/src/mem.c ****  * rt_malloc. The released memory block is taken back to system heap.
 543:rt-thread/src/mem.c ****  *
 544:rt-thread/src/mem.c ****  * @param rmem the address of memory which will be released
 545:rt-thread/src/mem.c ****  */
 546:rt-thread/src/mem.c **** void rt_free(void *rmem)
 547:rt-thread/src/mem.c **** {
 713              		.loc 1 547 0
 714              		.cfi_startproc
 715              		@ args = 0, pretend = 0, frame = 0
 716              		@ frame_needed = 0, uses_anonymous_args = 0
 717              	.LVL69:
 548:rt-thread/src/mem.c ****     struct heap_mem *mem;
 549:rt-thread/src/mem.c **** 
 550:rt-thread/src/mem.c ****     if (rmem == RT_NULL)
 718              		.loc 1 550 0
 719 0000 0028     		cmp	r0, #0
 720 0002 00F08580 		beq	.L72
 547:rt-thread/src/mem.c ****     struct heap_mem *mem;
 721              		.loc 1 547 0
 722 0006 70B5     		push	{r4, r5, r6, lr}
 723              	.LCFI6:
 724              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/cchS3cuE.s 			page 24


 725              		.cfi_offset 4, -16
 726              		.cfi_offset 5, -12
 727              		.cfi_offset 6, -8
 728              		.cfi_offset 14, -4
 729 0008 0446     		mov	r4, r0
 730              	.LBB6:
 551:rt-thread/src/mem.c ****         return;
 552:rt-thread/src/mem.c **** 
 553:rt-thread/src/mem.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 731              		.loc 1 553 0
 732 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 733              	.LVL70:
 734 000e 0546     		mov	r5, r0
 735              	.LVL71:
 736 0010 FFF7FEFF 		bl	rt_interrupt_get_nest
 737              	.LVL72:
 738 0014 E0B9     		cbnz	r0, .L75
 739              	.L62:
 740              		.loc 1 553 0 is_stmt 0 discriminator 5
 741 0016 2846     		mov	r0, r5
 742 0018 FFF7FEFF 		bl	rt_hw_interrupt_enable
 743              	.LVL73:
 744              	.LBE6:
 554:rt-thread/src/mem.c **** 
 555:rt-thread/src/mem.c ****     RT_ASSERT((((rt_ubase_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0);
 745              		.loc 1 555 0 is_stmt 1 discriminator 5
 746 001c 14F0030F 		tst	r4, #3
 747 0020 22D1     		bne	.L76
 748              	.L63:
 556:rt-thread/src/mem.c ****     RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
 749              		.loc 1 556 0
 750 0022 3C4B     		ldr	r3, .L79
 751 0024 1B68     		ldr	r3, [r3]
 752 0026 9C42     		cmp	r4, r3
 753 0028 03D3     		bcc	.L64
 754              		.loc 1 556 0 is_stmt 0 discriminator 2
 755 002a 3B4B     		ldr	r3, .L79+4
 756 002c 1B68     		ldr	r3, [r3]
 757 002e 9C42     		cmp	r4, r3
 758 0030 05D3     		bcc	.L65
 759              	.L64:
 760              		.loc 1 556 0 discriminator 3
 761 0032 40F22D22 		movw	r2, #557
 762 0036 3949     		ldr	r1, .L79+8
 763 0038 3948     		ldr	r0, .L79+12
 764 003a FFF7FEFF 		bl	rt_assert_handler
 765              	.LVL74:
 766              	.L65:
 557:rt-thread/src/mem.c ****               (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);
 558:rt-thread/src/mem.c **** 
 559:rt-thread/src/mem.c ****     RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
 560:rt-thread/src/mem.c **** 
 561:rt-thread/src/mem.c ****     if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
 767              		.loc 1 561 0 is_stmt 1
 768 003e 354B     		ldr	r3, .L79
 769 0040 1B68     		ldr	r3, [r3]
 770 0042 9C42     		cmp	r4, r3
ARM GAS  /tmp/cchS3cuE.s 			page 25


 771 0044 03D3     		bcc	.L60
 562:rt-thread/src/mem.c ****         (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 772              		.loc 1 562 0 discriminator 1
 773 0046 344B     		ldr	r3, .L79+4
 774 0048 1B68     		ldr	r3, [r3]
 561:rt-thread/src/mem.c ****         (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 775              		.loc 1 561 0 discriminator 1
 776 004a 9C42     		cmp	r4, r3
 777 004c 13D3     		bcc	.L77
 778              	.LVL75:
 779              	.L60:
 780 004e 70BD     		pop	{r4, r5, r6, pc}
 781              	.LVL76:
 782              	.L75:
 783              	.LBB7:
 553:rt-thread/src/mem.c **** 
 784              		.loc 1 553 0 discriminator 1
 785 0050 324E     		ldr	r6, .L79+8
 786 0052 3146     		mov	r1, r6
 787 0054 3348     		ldr	r0, .L79+16
 788 0056 FFF7FEFF 		bl	rt_kprintf
 789              	.LVL77:
 790 005a 40F22922 		movw	r2, #553
 791 005e 3146     		mov	r1, r6
 792 0060 3148     		ldr	r0, .L79+20
 793 0062 FFF7FEFF 		bl	rt_assert_handler
 794              	.LVL78:
 795 0066 D6E7     		b	.L62
 796              	.L76:
 797              	.LBE7:
 555:rt-thread/src/mem.c ****     RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
 798              		.loc 1 555 0 discriminator 1
 799 0068 40F22B22 		movw	r2, #555
 800 006c 2B49     		ldr	r1, .L79+8
 801 006e 2F48     		ldr	r0, .L79+24
 802 0070 FFF7FEFF 		bl	rt_assert_handler
 803              	.LVL79:
 804 0074 D5E7     		b	.L63
 805              	.L77:
 563:rt-thread/src/mem.c ****     {
 564:rt-thread/src/mem.c ****         RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));
 565:rt-thread/src/mem.c **** 
 566:rt-thread/src/mem.c ****         return;
 567:rt-thread/src/mem.c ****     }
 568:rt-thread/src/mem.c **** 
 569:rt-thread/src/mem.c ****     /* Get the corresponding struct heap_mem ... */
 570:rt-thread/src/mem.c ****     mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
 806              		.loc 1 570 0
 807 0076 A4F10C05 		sub	r5, r4, #12
 808              	.LVL80:
 571:rt-thread/src/mem.c **** 
 572:rt-thread/src/mem.c ****     RT_DEBUG_LOG(RT_DEBUG_MEM,
 573:rt-thread/src/mem.c ****                  ("release memory 0x%x, size: %d\n",
 574:rt-thread/src/mem.c ****                   (rt_ubase_t)rmem,
 575:rt-thread/src/mem.c ****                   (rt_ubase_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
 576:rt-thread/src/mem.c **** 
 577:rt-thread/src/mem.c **** 
ARM GAS  /tmp/cchS3cuE.s 			page 26


 578:rt-thread/src/mem.c ****     /* protect the heap from concurrent access */
 579:rt-thread/src/mem.c ****     rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
 809              		.loc 1 579 0
 810 007a 4FF0FF31 		mov	r1, #-1
 811 007e 2C48     		ldr	r0, .L79+28
 812 0080 FFF7FEFF 		bl	rt_sem_take
 813              	.LVL81:
 580:rt-thread/src/mem.c **** 
 581:rt-thread/src/mem.c ****     /* ... which has to be in a used state ... */
 582:rt-thread/src/mem.c ****     if (!mem->used || mem->magic != HEAP_MAGIC)
 814              		.loc 1 582 0
 815 0084 34F80A3C 		ldrh	r3, [r4, #-10]
 816 0088 23B1     		cbz	r3, .L66
 817              		.loc 1 582 0 is_stmt 0 discriminator 1
 818 008a 34F80C3C 		ldrh	r3, [r4, #-12]
 819 008e B3F5F55F 		cmp	r3, #7840
 820 0092 0AD0     		beq	.L67
 821              	.L66:
 583:rt-thread/src/mem.c ****     {
 584:rt-thread/src/mem.c ****         rt_kprintf("to free a bad data block:\n");
 822              		.loc 1 584 0 is_stmt 1
 823 0094 2748     		ldr	r0, .L79+32
 824 0096 FFF7FEFF 		bl	rt_kprintf
 825              	.LVL82:
 585:rt-thread/src/mem.c ****         rt_kprintf("mem: 0x%08x, used flag: %d, magic code: 0x%04x\n", mem, mem->used, mem->magic);
 826              		.loc 1 585 0
 827 009a 34F80C3C 		ldrh	r3, [r4, #-12]
 828 009e 34F80A2C 		ldrh	r2, [r4, #-10]
 829 00a2 2946     		mov	r1, r5
 830 00a4 2448     		ldr	r0, .L79+36
 831 00a6 FFF7FEFF 		bl	rt_kprintf
 832              	.LVL83:
 833              	.L67:
 586:rt-thread/src/mem.c ****     }
 587:rt-thread/src/mem.c ****     RT_ASSERT(mem->used);
 834              		.loc 1 587 0
 835 00aa 34F80A3C 		ldrh	r3, [r4, #-10]
 836 00ae 43B3     		cbz	r3, .L78
 837              	.L68:
 588:rt-thread/src/mem.c ****     RT_ASSERT(mem->magic == HEAP_MAGIC);
 838              		.loc 1 588 0
 839 00b0 34F80C3C 		ldrh	r3, [r4, #-12]
 840 00b4 B3F5F55F 		cmp	r3, #7840
 841 00b8 05D0     		beq	.L69
 842              		.loc 1 588 0 is_stmt 0 discriminator 1
 843 00ba 4FF41372 		mov	r2, #588
 844 00be 1749     		ldr	r1, .L79+8
 845 00c0 1E48     		ldr	r0, .L79+40
 846 00c2 FFF7FEFF 		bl	rt_assert_handler
 847              	.LVL84:
 848              	.L69:
 589:rt-thread/src/mem.c ****     /* ... and is now unused. */
 590:rt-thread/src/mem.c ****     mem->used  = 0;
 849              		.loc 1 590 0 is_stmt 1
 850 00c6 0023     		movs	r3, #0
 851 00c8 24F80A3C 		strh	r3, [r4, #-10]	@ movhi
 591:rt-thread/src/mem.c ****     mem->magic = HEAP_MAGIC;
ARM GAS  /tmp/cchS3cuE.s 			page 27


 852              		.loc 1 591 0
 853 00cc 4FF4F553 		mov	r3, #7840
 854 00d0 24F80C3C 		strh	r3, [r4, #-12]	@ movhi
 592:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 593:rt-thread/src/mem.c ****     rt_mem_setname(mem, "    ");
 594:rt-thread/src/mem.c **** #endif
 595:rt-thread/src/mem.c **** 
 596:rt-thread/src/mem.c ****     if (mem < lfree)
 855              		.loc 1 596 0
 856 00d4 1A4B     		ldr	r3, .L79+44
 857 00d6 1B68     		ldr	r3, [r3]
 858 00d8 9D42     		cmp	r5, r3
 859 00da 01D2     		bcs	.L70
 597:rt-thread/src/mem.c ****     {
 598:rt-thread/src/mem.c ****         /* the newly freed struct is now the lowest */
 599:rt-thread/src/mem.c ****         lfree = mem;
 860              		.loc 1 599 0
 861 00dc 184B     		ldr	r3, .L79+44
 862 00de 1D60     		str	r5, [r3]
 863              	.L70:
 600:rt-thread/src/mem.c ****     }
 601:rt-thread/src/mem.c **** 
 602:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 603:rt-thread/src/mem.c ****     used_mem -= (mem->next - ((rt_uint8_t *)mem - heap_ptr));
 864              		.loc 1 603 0
 865 00e0 0C4B     		ldr	r3, .L79
 866 00e2 1B68     		ldr	r3, [r3]
 867 00e4 EB1A     		subs	r3, r5, r3
 868 00e6 54F8082C 		ldr	r2, [r4, #-8]
 869 00ea 9B1A     		subs	r3, r3, r2
 870 00ec 1549     		ldr	r1, .L79+48
 871 00ee 0A68     		ldr	r2, [r1]
 872 00f0 1344     		add	r3, r3, r2
 873 00f2 0B60     		str	r3, [r1]
 604:rt-thread/src/mem.c **** #endif
 605:rt-thread/src/mem.c **** 
 606:rt-thread/src/mem.c ****     /* finally, see if prev or next are free also */
 607:rt-thread/src/mem.c ****     plug_holes(mem);
 874              		.loc 1 607 0
 875 00f4 2846     		mov	r0, r5
 876 00f6 FFF7FEFF 		bl	plug_holes
 877              	.LVL85:
 608:rt-thread/src/mem.c ****     rt_sem_release(&heap_sem);
 878              		.loc 1 608 0
 879 00fa 0D48     		ldr	r0, .L79+28
 880 00fc FFF7FEFF 		bl	rt_sem_release
 881              	.LVL86:
 882 0100 A5E7     		b	.L60
 883              	.L78:
 587:rt-thread/src/mem.c ****     RT_ASSERT(mem->magic == HEAP_MAGIC);
 884              		.loc 1 587 0 discriminator 1
 885 0102 40F24B22 		movw	r2, #587
 886 0106 0549     		ldr	r1, .L79+8
 887 0108 0F48     		ldr	r0, .L79+52
 888 010a FFF7FEFF 		bl	rt_assert_handler
 889              	.LVL87:
 890 010e CFE7     		b	.L68
ARM GAS  /tmp/cchS3cuE.s 			page 28


 891              	.LVL88:
 892              	.L72:
 893              	.LCFI7:
 894              		.cfi_def_cfa_offset 0
 895              		.cfi_restore 4
 896              		.cfi_restore 5
 897              		.cfi_restore 6
 898              		.cfi_restore 14
 899 0110 7047     		bx	lr
 900              	.L80:
 901 0112 00BF     		.align	2
 902              	.L79:
 903 0114 00000000 		.word	.LANCHOR0
 904 0118 00000000 		.word	.LANCHOR2
 905 011c 00000000 		.word	.LANCHOR10
 906 0120 30000000 		.word	.LC12
 907 0124 00000000 		.word	.LC3
 908 0128 28000000 		.word	.LC4
 909 012c 00000000 		.word	.LC11
 910 0130 00000000 		.word	.LANCHOR6
 911 0134 8C000000 		.word	.LC13
 912 0138 A8000000 		.word	.LC14
 913 013c E4000000 		.word	.LC16
 914 0140 00000000 		.word	.LANCHOR3
 915 0144 00000000 		.word	.LANCHOR8
 916 0148 D8000000 		.word	.LC15
 917              		.cfi_endproc
 918              	.LFE20:
 920              		.section	.text.rt_realloc,"ax",%progbits
 921              		.align	1
 922              		.global	rt_realloc
 923              		.syntax unified
 924              		.thumb
 925              		.thumb_func
 926              		.fpu fpv4-sp-d16
 928              	rt_realloc:
 929              	.LFB18:
 422:rt-thread/src/mem.c ****     rt_size_t size;
 930              		.loc 1 422 0
 931              		.cfi_startproc
 932              		@ args = 0, pretend = 0, frame = 0
 933              		@ frame_needed = 0, uses_anonymous_args = 0
 934              	.LVL89:
 935 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 936              	.LCFI8:
 937              		.cfi_def_cfa_offset 24
 938              		.cfi_offset 3, -24
 939              		.cfi_offset 4, -20
 940              		.cfi_offset 5, -16
 941              		.cfi_offset 6, -12
 942              		.cfi_offset 7, -8
 943              		.cfi_offset 14, -4
 944 0002 0546     		mov	r5, r0
 945 0004 0C46     		mov	r4, r1
 946              	.LBB8:
 428:rt-thread/src/mem.c **** 
 947              		.loc 1 428 0
ARM GAS  /tmp/cchS3cuE.s 			page 29


 948 0006 FFF7FEFF 		bl	rt_hw_interrupt_disable
 949              	.LVL90:
 950 000a 0646     		mov	r6, r0
 951              	.LVL91:
 952 000c FFF7FEFF 		bl	rt_interrupt_get_nest
 953              	.LVL92:
 954 0010 0028     		cmp	r0, #0
 955 0012 49D1     		bne	.L93
 956              	.L82:
 428:rt-thread/src/mem.c **** 
 957              		.loc 1 428 0 is_stmt 0 discriminator 5
 958 0014 3046     		mov	r0, r6
 959 0016 FFF7FEFF 		bl	rt_hw_interrupt_enable
 960              	.LVL93:
 961              	.LBE8:
 431:rt-thread/src/mem.c ****     if (newsize > mem_size_aligned)
 962              		.loc 1 431 0 is_stmt 1 discriminator 5
 963 001a 0334     		adds	r4, r4, #3
 964              	.LVL94:
 965 001c 24F00304 		bic	r4, r4, #3
 966              	.LVL95:
 432:rt-thread/src/mem.c ****     {
 967              		.loc 1 432 0 discriminator 5
 968 0020 3D4B     		ldr	r3, .L97
 969 0022 1B68     		ldr	r3, [r3]
 970 0024 9C42     		cmp	r4, r3
 971 0026 74D8     		bhi	.L91
 438:rt-thread/src/mem.c ****     {
 972              		.loc 1 438 0
 973 0028 002C     		cmp	r4, #0
 974 002a 49D0     		beq	.L94
 445:rt-thread/src/mem.c ****         return rt_malloc(newsize);
 975              		.loc 1 445 0
 976 002c 002D     		cmp	r5, #0
 977 002e 4CD0     		beq	.L95
 448:rt-thread/src/mem.c **** 
 978              		.loc 1 448 0
 979 0030 4FF0FF31 		mov	r1, #-1
 980 0034 3948     		ldr	r0, .L97+4
 981 0036 FFF7FEFF 		bl	rt_sem_take
 982              	.LVL96:
 450:rt-thread/src/mem.c ****         (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 983              		.loc 1 450 0
 984 003a 394B     		ldr	r3, .L97+8
 985 003c 1B68     		ldr	r3, [r3]
 986 003e 9D42     		cmp	r5, r3
 987 0040 48D3     		bcc	.L86
 451:rt-thread/src/mem.c ****     {
 988              		.loc 1 451 0 discriminator 1
 989 0042 384A     		ldr	r2, .L97+12
 990 0044 1268     		ldr	r2, [r2]
 450:rt-thread/src/mem.c ****         (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
 991              		.loc 1 450 0 discriminator 1
 992 0046 9542     		cmp	r5, r2
 993 0048 44D2     		bcs	.L86
 459:rt-thread/src/mem.c **** 
 994              		.loc 1 459 0
ARM GAS  /tmp/cchS3cuE.s 			page 30


 995 004a A5F10C02 		sub	r2, r5, #12
 996              	.LVL97:
 461:rt-thread/src/mem.c ****     size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 997              		.loc 1 461 0
 998 004e D21A     		subs	r2, r2, r3
 999              	.LVL98:
 462:rt-thread/src/mem.c ****     if (size == newsize)
 1000              		.loc 1 462 0
 1001 0050 55F8086C 		ldr	r6, [r5, #-8]
 1002              	.LVL99:
 1003 0054 B61A     		subs	r6, r6, r2
 1004 0056 0C3E     		subs	r6, r6, #12
 1005              	.LVL100:
 463:rt-thread/src/mem.c ****     {
 1006              		.loc 1 463 0
 1007 0058 B442     		cmp	r4, r6
 1008 005a 41D0     		beq	.L96
 471:rt-thread/src/mem.c ****     {
 1009              		.loc 1 471 0
 1010 005c 04F11801 		add	r1, r4, #24
 1011 0060 8E42     		cmp	r6, r1
 1012 0062 42D9     		bls	.L89
 475:rt-thread/src/mem.c **** #endif
 1013              		.loc 1 475 0
 1014 0064 A61B     		subs	r6, r4, r6
 1015              	.LVL101:
 1016 0066 3048     		ldr	r0, .L97+16
 1017 0068 0168     		ldr	r1, [r0]
 1018 006a 0E44     		add	r6, r6, r1
 1019 006c 0660     		str	r6, [r0]
 478:rt-thread/src/mem.c ****         mem2 = (struct heap_mem *)&heap_ptr[ptr2];
 1020              		.loc 1 478 0
 1021 006e 1444     		add	r4, r4, r2
 1022              	.LVL102:
 1023 0070 0C34     		adds	r4, r4, #12
 1024              	.LVL103:
 479:rt-thread/src/mem.c ****         mem2->magic = HEAP_MAGIC;
 1025              		.loc 1 479 0
 1026 0072 1819     		adds	r0, r3, r4
 1027              	.LVL104:
 480:rt-thread/src/mem.c ****         mem2->used = 0;
 1028              		.loc 1 480 0
 1029 0074 4FF4F551 		mov	r1, #7840
 1030 0078 1953     		strh	r1, [r3, r4]	@ movhi
 1031              	.LVL105:
 481:rt-thread/src/mem.c ****         mem2->next = mem->next;
 1032              		.loc 1 481 0
 1033 007a 0021     		movs	r1, #0
 1034 007c 4180     		strh	r1, [r0, #2]	@ movhi
 482:rt-thread/src/mem.c ****         mem2->prev = ptr;
 1035              		.loc 1 482 0
 1036 007e 55F8081C 		ldr	r1, [r5, #-8]
 1037 0082 4160     		str	r1, [r0, #4]
 483:rt-thread/src/mem.c **** #ifdef RT_USING_MEMTRACE
 1038              		.loc 1 483 0
 1039 0084 8260     		str	r2, [r0, #8]
 487:rt-thread/src/mem.c ****         if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
ARM GAS  /tmp/cchS3cuE.s 			page 31


 1040              		.loc 1 487 0
 1041 0086 45F8084C 		str	r4, [r5, #-8]
 488:rt-thread/src/mem.c ****         {
 1042              		.loc 1 488 0
 1043 008a 4168     		ldr	r1, [r0, #4]
 1044 008c 224A     		ldr	r2, .L97
 1045              	.LVL106:
 1046 008e 1268     		ldr	r2, [r2]
 1047 0090 0C32     		adds	r2, r2, #12
 1048 0092 9142     		cmp	r1, r2
 1049 0094 01D0     		beq	.L90
 490:rt-thread/src/mem.c ****         }
 1050              		.loc 1 490 0
 1051 0096 0B44     		add	r3, r3, r1
 1052              	.LVL107:
 1053 0098 9C60     		str	r4, [r3, #8]
 1054              	.L90:
 493:rt-thread/src/mem.c **** 
 1055              		.loc 1 493 0
 1056 009a FFF7FEFF 		bl	plug_holes
 1057              	.LVL108:
 495:rt-thread/src/mem.c **** 
 1058              		.loc 1 495 0
 1059 009e 1F48     		ldr	r0, .L97+4
 1060 00a0 FFF7FEFF 		bl	rt_sem_release
 1061              	.LVL109:
 497:rt-thread/src/mem.c ****     }
 1062              		.loc 1 497 0
 1063 00a4 2F46     		mov	r7, r5
 1064 00a6 19E0     		b	.L81
 1065              	.LVL110:
 1066              	.L93:
 1067              	.LBB9:
 428:rt-thread/src/mem.c **** 
 1068              		.loc 1 428 0 discriminator 1
 1069 00a8 204F     		ldr	r7, .L97+20
 1070 00aa 3946     		mov	r1, r7
 1071 00ac 2048     		ldr	r0, .L97+24
 1072 00ae FFF7FEFF 		bl	rt_kprintf
 1073              	.LVL111:
 1074 00b2 4FF4D672 		mov	r2, #428
 1075 00b6 3946     		mov	r1, r7
 1076 00b8 1E48     		ldr	r0, .L97+28
 1077 00ba FFF7FEFF 		bl	rt_assert_handler
 1078              	.LVL112:
 1079 00be A9E7     		b	.L82
 1080              	.L94:
 1081              	.LBE9:
 440:rt-thread/src/mem.c ****         return RT_NULL;
 1082              		.loc 1 440 0
 1083 00c0 2846     		mov	r0, r5
 1084 00c2 FFF7FEFF 		bl	rt_free
 1085              	.LVL113:
 441:rt-thread/src/mem.c ****     }
 1086              		.loc 1 441 0
 1087 00c6 0027     		movs	r7, #0
 1088 00c8 08E0     		b	.L81
ARM GAS  /tmp/cchS3cuE.s 			page 32


 1089              	.L95:
 446:rt-thread/src/mem.c **** 
 1090              		.loc 1 446 0
 1091 00ca 2046     		mov	r0, r4
 1092 00cc FFF7FEFF 		bl	rt_malloc
 1093              	.LVL114:
 1094 00d0 0746     		mov	r7, r0
 1095 00d2 03E0     		b	.L81
 1096              	.L86:
 454:rt-thread/src/mem.c **** 
 1097              		.loc 1 454 0
 1098 00d4 1148     		ldr	r0, .L97+4
 1099 00d6 FFF7FEFF 		bl	rt_sem_release
 1100              	.LVL115:
 456:rt-thread/src/mem.c ****     }
 1101              		.loc 1 456 0
 1102 00da 2F46     		mov	r7, r5
 1103              	.LVL116:
 1104              	.L81:
 510:rt-thread/src/mem.c **** RTM_EXPORT(rt_realloc);
 1105              		.loc 1 510 0
 1106 00dc 3846     		mov	r0, r7
 1107 00de F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1108              	.LVL117:
 1109              	.L96:
 466:rt-thread/src/mem.c **** 
 1110              		.loc 1 466 0
 1111 00e0 0E48     		ldr	r0, .L97+4
 1112 00e2 FFF7FEFF 		bl	rt_sem_release
 1113              	.LVL118:
 468:rt-thread/src/mem.c ****     }
 1114              		.loc 1 468 0
 1115 00e6 2F46     		mov	r7, r5
 1116 00e8 F8E7     		b	.L81
 1117              	.LVL119:
 1118              	.L89:
 499:rt-thread/src/mem.c **** 
 1119              		.loc 1 499 0
 1120 00ea 0C48     		ldr	r0, .L97+4
 1121 00ec FFF7FEFF 		bl	rt_sem_release
 1122              	.LVL120:
 502:rt-thread/src/mem.c ****     if (nmem != RT_NULL) /* check memory */
 1123              		.loc 1 502 0
 1124 00f0 2046     		mov	r0, r4
 1125 00f2 FFF7FEFF 		bl	rt_malloc
 1126              	.LVL121:
 503:rt-thread/src/mem.c ****     {
 1127              		.loc 1 503 0
 1128 00f6 0746     		mov	r7, r0
 1129 00f8 0028     		cmp	r0, #0
 1130 00fa EFD0     		beq	.L81
 505:rt-thread/src/mem.c ****         rt_free(rmem);
 1131              		.loc 1 505 0
 1132 00fc 2246     		mov	r2, r4
 1133 00fe B442     		cmp	r4, r6
 1134 0100 28BF     		it	cs
 1135 0102 3246     		movcs	r2, r6
ARM GAS  /tmp/cchS3cuE.s 			page 33


 1136 0104 2946     		mov	r1, r5
 1137 0106 FFF7FEFF 		bl	rt_memcpy
 1138              	.LVL122:
 506:rt-thread/src/mem.c ****     }
 1139              		.loc 1 506 0
 1140 010a 2846     		mov	r0, r5
 1141 010c FFF7FEFF 		bl	rt_free
 1142              	.LVL123:
 1143 0110 E4E7     		b	.L81
 1144              	.LVL124:
 1145              	.L91:
 436:rt-thread/src/mem.c ****     }
 1146              		.loc 1 436 0
 1147 0112 0027     		movs	r7, #0
 1148 0114 E2E7     		b	.L81
 1149              	.L98:
 1150 0116 00BF     		.align	2
 1151              	.L97:
 1152 0118 00000000 		.word	.LANCHOR5
 1153 011c 00000000 		.word	.LANCHOR6
 1154 0120 00000000 		.word	.LANCHOR0
 1155 0124 00000000 		.word	.LANCHOR2
 1156 0128 00000000 		.word	.LANCHOR8
 1157 012c 00000000 		.word	.LANCHOR11
 1158 0130 00000000 		.word	.LC3
 1159 0134 28000000 		.word	.LC4
 1160              		.cfi_endproc
 1161              	.LFE18:
 1163              		.section	.text.rt_memory_info,"ax",%progbits
 1164              		.align	1
 1165              		.global	rt_memory_info
 1166              		.syntax unified
 1167              		.thumb
 1168              		.thumb_func
 1169              		.fpu fpv4-sp-d16
 1171              	rt_memory_info:
 1172              	.LFB21:
 609:rt-thread/src/mem.c **** }
 610:rt-thread/src/mem.c **** RTM_EXPORT(rt_free);
 611:rt-thread/src/mem.c **** 
 612:rt-thread/src/mem.c **** #ifdef RT_MEM_STATS
 613:rt-thread/src/mem.c **** void rt_memory_info(rt_uint32_t *total,
 614:rt-thread/src/mem.c ****                     rt_uint32_t *used,
 615:rt-thread/src/mem.c ****                     rt_uint32_t *max_used)
 616:rt-thread/src/mem.c **** {
 1173              		.loc 1 616 0
 1174              		.cfi_startproc
 1175              		@ args = 0, pretend = 0, frame = 0
 1176              		@ frame_needed = 0, uses_anonymous_args = 0
 1177              		@ link register save eliminated.
 1178              	.LVL125:
 617:rt-thread/src/mem.c ****     if (total != RT_NULL)
 1179              		.loc 1 617 0
 1180 0000 0346     		mov	r3, r0
 1181 0002 10B1     		cbz	r0, .L100
 618:rt-thread/src/mem.c ****         *total = mem_size_aligned;
 1182              		.loc 1 618 0
ARM GAS  /tmp/cchS3cuE.s 			page 34


 1183 0004 0548     		ldr	r0, .L103
 1184              	.LVL126:
 1185 0006 0068     		ldr	r0, [r0]
 1186 0008 1860     		str	r0, [r3]
 1187              	.L100:
 619:rt-thread/src/mem.c ****     if (used  != RT_NULL)
 1188              		.loc 1 619 0
 1189 000a 11B1     		cbz	r1, .L101
 620:rt-thread/src/mem.c ****         *used = used_mem;
 1190              		.loc 1 620 0
 1191 000c 044B     		ldr	r3, .L103+4
 1192              	.LVL127:
 1193 000e 1B68     		ldr	r3, [r3]
 1194 0010 0B60     		str	r3, [r1]
 1195              	.L101:
 621:rt-thread/src/mem.c ****     if (max_used != RT_NULL)
 1196              		.loc 1 621 0
 1197 0012 12B1     		cbz	r2, .L99
 622:rt-thread/src/mem.c ****         *max_used = max_mem;
 1198              		.loc 1 622 0
 1199 0014 034B     		ldr	r3, .L103+8
 1200 0016 1B68     		ldr	r3, [r3]
 1201 0018 1360     		str	r3, [r2]
 1202              	.L99:
 1203 001a 7047     		bx	lr
 1204              	.L104:
 1205              		.align	2
 1206              	.L103:
 1207 001c 00000000 		.word	.LANCHOR5
 1208 0020 00000000 		.word	.LANCHOR8
 1209 0024 00000000 		.word	.LANCHOR9
 1210              		.cfi_endproc
 1211              	.LFE21:
 1213              		.section	.bss.heap_end,"aw",%nobits
 1214              		.align	2
 1215              		.set	.LANCHOR2,. + 0
 1218              	heap_end:
 1219 0000 00000000 		.space	4
 1220              		.section	.bss.heap_ptr,"aw",%nobits
 1221              		.align	2
 1222              		.set	.LANCHOR0,. + 0
 1225              	heap_ptr:
 1226 0000 00000000 		.space	4
 1227              		.section	.bss.heap_sem,"aw",%nobits
 1228              		.align	2
 1229              		.set	.LANCHOR6,. + 0
 1232              	heap_sem:
 1233 0000 00000000 		.space	32
 1233      00000000 
 1233      00000000 
 1233      00000000 
 1233      00000000 
 1234              		.section	.bss.lfree,"aw",%nobits
 1235              		.align	2
 1236              		.set	.LANCHOR3,. + 0
 1239              	lfree:
 1240 0000 00000000 		.space	4
ARM GAS  /tmp/cchS3cuE.s 			page 35


 1241              		.section	.bss.max_mem,"aw",%nobits
 1242              		.align	2
 1243              		.set	.LANCHOR9,. + 0
 1246              	max_mem:
 1247 0000 00000000 		.space	4
 1248              		.section	.bss.mem_size_aligned,"aw",%nobits
 1249              		.align	2
 1250              		.set	.LANCHOR5,. + 0
 1253              	mem_size_aligned:
 1254 0000 00000000 		.space	4
 1255              		.section	.bss.used_mem,"aw",%nobits
 1256              		.align	2
 1257              		.set	.LANCHOR8,. + 0
 1260              	used_mem:
 1261 0000 00000000 		.space	4
 1262              		.section	.rodata.__FUNCTION__.6530,"a",%progbits
 1263              		.align	2
 1264              		.set	.LANCHOR1,. + 0
 1267              	__FUNCTION__.6530:
 1268 0000 706C7567 		.ascii	"plug_holes\000"
 1268      5F686F6C 
 1268      657300
 1269              		.section	.rodata.__FUNCTION__.6539,"a",%progbits
 1270              		.align	2
 1271              		.set	.LANCHOR4,. + 0
 1274              	__FUNCTION__.6539:
 1275 0000 72745F73 		.ascii	"rt_system_heap_init\000"
 1275      79737465 
 1275      6D5F6865 
 1275      61705F69 
 1275      6E697400 
 1276              		.section	.rodata.__FUNCTION__.6548,"a",%progbits
 1277              		.align	2
 1278              		.set	.LANCHOR7,. + 0
 1281              	__FUNCTION__.6548:
 1282 0000 72745F6D 		.ascii	"rt_malloc\000"
 1282      616C6C6F 
 1282      6300
 1283              		.section	.rodata.__FUNCTION__.6566,"a",%progbits
 1284              		.align	2
 1285              		.set	.LANCHOR11,. + 0
 1288              	__FUNCTION__.6566:
 1289 0000 72745F72 		.ascii	"rt_realloc\000"
 1289      65616C6C 
 1289      6F6300
 1290              		.section	.rodata.__FUNCTION__.6577,"a",%progbits
 1291              		.align	2
 1292              		.set	.LANCHOR10,. + 0
 1295              	__FUNCTION__.6577:
 1296 0000 72745F66 		.ascii	"rt_free\000"
 1296      72656500 
 1297              		.section	.rodata.plug_holes.str1.4,"aMS",%progbits,1
 1298              		.align	2
 1299              	.LC0:
 1300 0000 2872745F 		.ascii	"(rt_uint8_t *)mem >= heap_ptr\000"
 1300      75696E74 
 1300      385F7420 
ARM GAS  /tmp/cchS3cuE.s 			page 36


 1300      2A296D65 
 1300      6D203E3D 
 1301 001e 0000     		.space	2
 1302              	.LC1:
 1303 0020 2872745F 		.ascii	"(rt_uint8_t *)mem < (rt_uint8_t *)heap_end\000"
 1303      75696E74 
 1303      385F7420 
 1303      2A296D65 
 1303      6D203C20 
 1304 004b 00       		.space	1
 1305              	.LC2:
 1306 004c 6D656D2D 		.ascii	"mem->used == 0\000"
 1306      3E757365 
 1306      64203D3D 
 1306      203000
 1307              		.section	.rodata.rt_free.str1.4,"aMS",%progbits,1
 1308              		.align	2
 1309              	.LC11:
 1310 0000 28282872 		.ascii	"(((rt_ubase_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0\000"
 1310      745F7562 
 1310      6173655F 
 1310      7429726D 
 1310      656D2920 
 1311              	.LC12:
 1312 0030 2872745F 		.ascii	"(rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr && (rt"
 1312      75696E74 
 1312      385F7420 
 1312      2A29726D 
 1312      656D203E 
 1313 0063 5F75696E 		.ascii	"_uint8_t *)rmem < (rt_uint8_t *)heap_end\000"
 1313      74385F74 
 1313      202A2972 
 1313      6D656D20 
 1313      3C202872 
 1314              	.LC13:
 1315 008c 746F2066 		.ascii	"to free a bad data block:\012\000"
 1315      72656520 
 1315      61206261 
 1315      64206461 
 1315      74612062 
 1316 00a7 00       		.space	1
 1317              	.LC14:
 1318 00a8 6D656D3A 		.ascii	"mem: 0x%08x, used flag: %d, magic code: 0x%04x\012\000"
 1318      20307825 
 1318      3038782C 
 1318      20757365 
 1318      6420666C 
 1319              	.LC15:
 1320 00d8 6D656D2D 		.ascii	"mem->used\000"
 1320      3E757365 
 1320      6400
 1321 00e2 0000     		.space	2
 1322              	.LC16:
 1323 00e4 6D656D2D 		.ascii	"mem->magic == HEAP_MAGIC\000"
 1323      3E6D6167 
 1323      6963203D 
 1323      3D204845 
ARM GAS  /tmp/cchS3cuE.s 			page 37


 1323      41505F4D 
 1324              		.section	.rodata.rt_malloc.str1.4,"aMS",%progbits,1
 1325              		.align	2
 1326              	.LC7:
 1327 0000 28286C66 		.ascii	"((lfree == heap_end) || (!lfree->used))\000"
 1327      72656520 
 1327      3D3D2068 
 1327      6561705F 
 1327      656E6429 
 1328              	.LC8:
 1329 0028 2872745F 		.ascii	"(rt_ubase_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_u"
 1329      75626173 
 1329      655F7429 
 1329      6D656D20 
 1329      2B205349 
 1330 005b 62617365 		.ascii	"base_t)heap_end\000"
 1330      5F742968 
 1330      6561705F 
 1330      656E6400 
 1331 006b 00       		.space	1
 1332              	.LC9:
 1333 006c 2872745F 		.ascii	"(rt_ubase_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)"
 1333      75626173 
 1333      655F7429 
 1333      28287274 
 1333      5F75696E 
 1334 009f 20252052 		.ascii	" % RT_ALIGN_SIZE == 0\000"
 1334      545F414C 
 1334      49474E5F 
 1334      53495A45 
 1334      203D3D20 
 1335 00b5 000000   		.space	3
 1336              	.LC10:
 1337 00b8 28282872 		.ascii	"(((rt_ubase_t)mem) & (RT_ALIGN_SIZE - 1)) == 0\000"
 1337      745F7562 
 1337      6173655F 
 1337      74296D65 
 1337      6D292026 
 1338              		.section	.rodata.rt_system_heap_init.str1.4,"aMS",%progbits,1
 1339              		.align	2
 1340              	.LC3:
 1341 0000 46756E63 		.ascii	"Function[%s] shall not be used in ISR\012\000"
 1341      74696F6E 
 1341      5B25735D 
 1341      20736861 
 1341      6C6C206E 
 1342 0027 00       		.space	1
 1343              	.LC4:
 1344 0028 3000     		.ascii	"0\000"
 1345 002a 0000     		.space	2
 1346              	.LC5:
 1347 002c 68656170 		.ascii	"heap\000"
 1347      00
 1348 0031 000000   		.space	3
 1349              	.LC6:
 1350 0034 6D656D20 		.ascii	"mem init, error begin address 0x%x, and end address"
 1350      696E6974 
ARM GAS  /tmp/cchS3cuE.s 			page 38


 1350      2C206572 
 1350      726F7220 
 1350      62656769 
 1351 0067 20307825 		.ascii	" 0x%x\012\000"
 1351      780A00
 1352              		.text
 1353              	.Letext0:
 1354              		.file 2 "rt-thread/include/rtdef.h"
 1355              		.file 3 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 1356              		.file 4 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 1357              		.file 5 "/opt/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 1358              		.file 6 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 1359              		.file 7 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/time.h"
 1360              		.file 8 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/errno.h"
 1361              		.file 9 "rt-thread/include/rtthread.h"
 1362              		.file 10 "rt-thread/include/rthw.h"
ARM GAS  /tmp/cchS3cuE.s 			page 39


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mem.c
     /tmp/cchS3cuE.s:18     .text.plug_holes:0000000000000000 $t
     /tmp/cchS3cuE.s:24     .text.plug_holes:0000000000000000 plug_holes
     /tmp/cchS3cuE.s:159    .text.plug_holes:0000000000000098 $d
     /tmp/cchS3cuE.s:170    .text.rt_system_heap_init:0000000000000000 $t
     /tmp/cchS3cuE.s:177    .text.rt_system_heap_init:0000000000000000 rt_system_heap_init
     /tmp/cchS3cuE.s:302    .text.rt_system_heap_init:0000000000000098 $d
     /tmp/cchS3cuE.s:316    .text.rt_malloc:0000000000000000 $t
     /tmp/cchS3cuE.s:323    .text.rt_malloc:0000000000000000 rt_malloc
     /tmp/cchS3cuE.s:643    .text.rt_malloc:000000000000018c $d
     /tmp/cchS3cuE.s:661    .text.rt_calloc:0000000000000000 $t
     /tmp/cchS3cuE.s:668    .text.rt_calloc:0000000000000000 rt_calloc
     /tmp/cchS3cuE.s:704    .text.rt_free:0000000000000000 $t
     /tmp/cchS3cuE.s:711    .text.rt_free:0000000000000000 rt_free
     /tmp/cchS3cuE.s:903    .text.rt_free:0000000000000114 $d
     /tmp/cchS3cuE.s:921    .text.rt_realloc:0000000000000000 $t
     /tmp/cchS3cuE.s:928    .text.rt_realloc:0000000000000000 rt_realloc
     /tmp/cchS3cuE.s:1152   .text.rt_realloc:0000000000000118 $d
     /tmp/cchS3cuE.s:1164   .text.rt_memory_info:0000000000000000 $t
     /tmp/cchS3cuE.s:1171   .text.rt_memory_info:0000000000000000 rt_memory_info
     /tmp/cchS3cuE.s:1207   .text.rt_memory_info:000000000000001c $d
     /tmp/cchS3cuE.s:1214   .bss.heap_end:0000000000000000 $d
     /tmp/cchS3cuE.s:1218   .bss.heap_end:0000000000000000 heap_end
     /tmp/cchS3cuE.s:1221   .bss.heap_ptr:0000000000000000 $d
     /tmp/cchS3cuE.s:1225   .bss.heap_ptr:0000000000000000 heap_ptr
     /tmp/cchS3cuE.s:1228   .bss.heap_sem:0000000000000000 $d
     /tmp/cchS3cuE.s:1232   .bss.heap_sem:0000000000000000 heap_sem
     /tmp/cchS3cuE.s:1235   .bss.lfree:0000000000000000 $d
     /tmp/cchS3cuE.s:1239   .bss.lfree:0000000000000000 lfree
     /tmp/cchS3cuE.s:1242   .bss.max_mem:0000000000000000 $d
     /tmp/cchS3cuE.s:1246   .bss.max_mem:0000000000000000 max_mem
     /tmp/cchS3cuE.s:1249   .bss.mem_size_aligned:0000000000000000 $d
     /tmp/cchS3cuE.s:1253   .bss.mem_size_aligned:0000000000000000 mem_size_aligned
     /tmp/cchS3cuE.s:1256   .bss.used_mem:0000000000000000 $d
     /tmp/cchS3cuE.s:1260   .bss.used_mem:0000000000000000 used_mem
     /tmp/cchS3cuE.s:1263   .rodata.__FUNCTION__.6530:0000000000000000 $d
     /tmp/cchS3cuE.s:1267   .rodata.__FUNCTION__.6530:0000000000000000 __FUNCTION__.6530
     /tmp/cchS3cuE.s:1270   .rodata.__FUNCTION__.6539:0000000000000000 $d
     /tmp/cchS3cuE.s:1274   .rodata.__FUNCTION__.6539:0000000000000000 __FUNCTION__.6539
     /tmp/cchS3cuE.s:1277   .rodata.__FUNCTION__.6548:0000000000000000 $d
     /tmp/cchS3cuE.s:1281   .rodata.__FUNCTION__.6548:0000000000000000 __FUNCTION__.6548
     /tmp/cchS3cuE.s:1284   .rodata.__FUNCTION__.6566:0000000000000000 $d
     /tmp/cchS3cuE.s:1288   .rodata.__FUNCTION__.6566:0000000000000000 __FUNCTION__.6566
     /tmp/cchS3cuE.s:1291   .rodata.__FUNCTION__.6577:0000000000000000 $d
     /tmp/cchS3cuE.s:1295   .rodata.__FUNCTION__.6577:0000000000000000 __FUNCTION__.6577
     /tmp/cchS3cuE.s:1298   .rodata.plug_holes.str1.4:0000000000000000 $d
     /tmp/cchS3cuE.s:1308   .rodata.rt_free.str1.4:0000000000000000 $d
     /tmp/cchS3cuE.s:1325   .rodata.rt_malloc.str1.4:0000000000000000 $d
     /tmp/cchS3cuE.s:1339   .rodata.rt_system_heap_init.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rt_assert_handler
rt_hw_interrupt_disable
rt_interrupt_get_nest
rt_hw_interrupt_enable
ARM GAS  /tmp/cchS3cuE.s 			page 40


rt_kprintf
rt_sem_init
rt_sem_take
rt_sem_release
rt_memset
rt_memcpy
