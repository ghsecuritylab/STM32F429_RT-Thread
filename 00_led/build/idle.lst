ARM GAS  /tmp/ccojy97u.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"idle.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.rt_thread_idle_excute,"ax",%progbits
  18              		.align	1
  19              		.global	rt_thread_idle_excute
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	rt_thread_idle_excute:
  26              	.LFB16:
  27              		.file 1 "rt-thread/src/idle.c"
   1:rt-thread/src/idle.c **** /*
   2:rt-thread/src/idle.c ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt-thread/src/idle.c ****  *
   4:rt-thread/src/idle.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt-thread/src/idle.c ****  *
   6:rt-thread/src/idle.c ****  * Change Logs:
   7:rt-thread/src/idle.c ****  * Date           Author       Notes
   8:rt-thread/src/idle.c ****  * 2006-03-23     Bernard      the first version
   9:rt-thread/src/idle.c ****  * 2010-11-10     Bernard      add cleanup callback function in thread exit.
  10:rt-thread/src/idle.c ****  * 2012-12-29     Bernard      fix compiling warning.
  11:rt-thread/src/idle.c ****  * 2013-12-21     Grissiom     let rt_thread_idle_excute loop until there is no
  12:rt-thread/src/idle.c ****  *                             dead thread.
  13:rt-thread/src/idle.c ****  * 2016-08-09     ArdaFu       add method to get the handler of the idle thread.
  14:rt-thread/src/idle.c ****  * 2018-02-07     Bernard      lock scheduler to protect tid->cleanup.
  15:rt-thread/src/idle.c ****  * 2018-07-14     armink       add idle hook list
  16:rt-thread/src/idle.c ****  * 2018-11-22     Jesven       add per cpu idle task
  17:rt-thread/src/idle.c ****  *                             combine the code of primary and secondary cpu
  18:rt-thread/src/idle.c ****  */
  19:rt-thread/src/idle.c **** 
  20:rt-thread/src/idle.c **** #include <rthw.h>
  21:rt-thread/src/idle.c **** #include <rtthread.h>
  22:rt-thread/src/idle.c **** 
  23:rt-thread/src/idle.c **** #ifdef RT_USING_MODULE
  24:rt-thread/src/idle.c **** #include <dlmodule.h>
  25:rt-thread/src/idle.c **** #endif
  26:rt-thread/src/idle.c **** 
  27:rt-thread/src/idle.c **** #if defined (RT_USING_HOOK)
  28:rt-thread/src/idle.c **** #ifndef RT_USING_IDLE_HOOK
  29:rt-thread/src/idle.c **** #define RT_USING_IDLE_HOOK
  30:rt-thread/src/idle.c **** #endif
  31:rt-thread/src/idle.c **** #endif
ARM GAS  /tmp/ccojy97u.s 			page 2


  32:rt-thread/src/idle.c **** 
  33:rt-thread/src/idle.c **** #ifndef IDLE_THREAD_STACK_SIZE
  34:rt-thread/src/idle.c **** #if defined (RT_USING_IDLE_HOOK) || defined(RT_USING_HEAP)
  35:rt-thread/src/idle.c **** #define IDLE_THREAD_STACK_SIZE  256
  36:rt-thread/src/idle.c **** #else
  37:rt-thread/src/idle.c **** #define IDLE_THREAD_STACK_SIZE  128
  38:rt-thread/src/idle.c **** #endif
  39:rt-thread/src/idle.c **** #endif
  40:rt-thread/src/idle.c **** 
  41:rt-thread/src/idle.c **** #ifdef RT_USING_SMP
  42:rt-thread/src/idle.c **** #define _CPUS_NR                RT_CPUS_NR
  43:rt-thread/src/idle.c **** #else
  44:rt-thread/src/idle.c **** #define _CPUS_NR                1
  45:rt-thread/src/idle.c **** #endif
  46:rt-thread/src/idle.c **** 
  47:rt-thread/src/idle.c **** extern rt_list_t rt_thread_defunct;
  48:rt-thread/src/idle.c **** 
  49:rt-thread/src/idle.c **** static struct rt_thread idle[_CPUS_NR];
  50:rt-thread/src/idle.c **** ALIGN(RT_ALIGN_SIZE)
  51:rt-thread/src/idle.c **** static rt_uint8_t rt_thread_stack[_CPUS_NR][IDLE_THREAD_STACK_SIZE];
  52:rt-thread/src/idle.c **** 
  53:rt-thread/src/idle.c **** #ifdef RT_USING_IDLE_HOOK
  54:rt-thread/src/idle.c **** #ifndef RT_IDLE_HOOK_LIST_SIZE
  55:rt-thread/src/idle.c **** #define RT_IDLE_HOOK_LIST_SIZE  4
  56:rt-thread/src/idle.c **** #endif
  57:rt-thread/src/idle.c **** 
  58:rt-thread/src/idle.c **** static void (*idle_hook_list[RT_IDLE_HOOK_LIST_SIZE])(void);
  59:rt-thread/src/idle.c **** 
  60:rt-thread/src/idle.c **** /**
  61:rt-thread/src/idle.c ****  * @ingroup Hook
  62:rt-thread/src/idle.c ****  * This function sets a hook function to idle thread loop. When the system performs
  63:rt-thread/src/idle.c ****  * idle loop, this hook function should be invoked.
  64:rt-thread/src/idle.c ****  *
  65:rt-thread/src/idle.c ****  * @param hook the specified hook function
  66:rt-thread/src/idle.c ****  *
  67:rt-thread/src/idle.c ****  * @return RT_EOK: set OK
  68:rt-thread/src/idle.c ****  *         -RT_EFULL: hook list is full
  69:rt-thread/src/idle.c ****  *
  70:rt-thread/src/idle.c ****  * @note the hook function must be simple and never be blocked or suspend.
  71:rt-thread/src/idle.c ****  */
  72:rt-thread/src/idle.c **** rt_err_t rt_thread_idle_sethook(void (*hook)(void))
  73:rt-thread/src/idle.c **** {
  74:rt-thread/src/idle.c ****     rt_size_t i;
  75:rt-thread/src/idle.c ****     rt_base_t level;
  76:rt-thread/src/idle.c ****     rt_err_t ret = -RT_EFULL;
  77:rt-thread/src/idle.c **** 
  78:rt-thread/src/idle.c ****     /* disable interrupt */
  79:rt-thread/src/idle.c ****     level = rt_hw_interrupt_disable();
  80:rt-thread/src/idle.c **** 
  81:rt-thread/src/idle.c ****     for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
  82:rt-thread/src/idle.c ****     {
  83:rt-thread/src/idle.c ****         if (idle_hook_list[i] == RT_NULL)
  84:rt-thread/src/idle.c ****         {
  85:rt-thread/src/idle.c ****             idle_hook_list[i] = hook;
  86:rt-thread/src/idle.c ****             ret = RT_EOK;
  87:rt-thread/src/idle.c ****             break;
  88:rt-thread/src/idle.c ****         }
ARM GAS  /tmp/ccojy97u.s 			page 3


  89:rt-thread/src/idle.c ****     }
  90:rt-thread/src/idle.c ****     /* enable interrupt */
  91:rt-thread/src/idle.c ****     rt_hw_interrupt_enable(level);
  92:rt-thread/src/idle.c **** 
  93:rt-thread/src/idle.c ****     return ret;
  94:rt-thread/src/idle.c **** }
  95:rt-thread/src/idle.c **** 
  96:rt-thread/src/idle.c **** /**
  97:rt-thread/src/idle.c ****  * delete the idle hook on hook list
  98:rt-thread/src/idle.c ****  *
  99:rt-thread/src/idle.c ****  * @param hook the specified hook function
 100:rt-thread/src/idle.c ****  *
 101:rt-thread/src/idle.c ****  * @return RT_EOK: delete OK
 102:rt-thread/src/idle.c ****  *         -RT_ENOSYS: hook was not found
 103:rt-thread/src/idle.c ****  */
 104:rt-thread/src/idle.c **** rt_err_t rt_thread_idle_delhook(void (*hook)(void))
 105:rt-thread/src/idle.c **** {
 106:rt-thread/src/idle.c ****     rt_size_t i;
 107:rt-thread/src/idle.c ****     rt_base_t level;
 108:rt-thread/src/idle.c ****     rt_err_t ret = -RT_ENOSYS;
 109:rt-thread/src/idle.c **** 
 110:rt-thread/src/idle.c ****     /* disable interrupt */
 111:rt-thread/src/idle.c ****     level = rt_hw_interrupt_disable();
 112:rt-thread/src/idle.c **** 
 113:rt-thread/src/idle.c ****     for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
 114:rt-thread/src/idle.c ****     {
 115:rt-thread/src/idle.c ****         if (idle_hook_list[i] == hook)
 116:rt-thread/src/idle.c ****         {
 117:rt-thread/src/idle.c ****             idle_hook_list[i] = RT_NULL;
 118:rt-thread/src/idle.c ****             ret = RT_EOK;
 119:rt-thread/src/idle.c ****             break;
 120:rt-thread/src/idle.c ****         }
 121:rt-thread/src/idle.c ****     }
 122:rt-thread/src/idle.c ****     /* enable interrupt */
 123:rt-thread/src/idle.c ****     rt_hw_interrupt_enable(level);
 124:rt-thread/src/idle.c **** 
 125:rt-thread/src/idle.c ****     return ret;
 126:rt-thread/src/idle.c **** }
 127:rt-thread/src/idle.c **** 
 128:rt-thread/src/idle.c **** #endif
 129:rt-thread/src/idle.c **** 
 130:rt-thread/src/idle.c **** /* Return whether there is defunctional thread to be deleted. */
 131:rt-thread/src/idle.c **** rt_inline int _has_defunct_thread(void)
 132:rt-thread/src/idle.c **** {
 133:rt-thread/src/idle.c ****     /* The rt_list_isempty has prototype of "int rt_list_isempty(const rt_list_t *l)".
 134:rt-thread/src/idle.c ****      * So the compiler has a good reason that the rt_thread_defunct list does
 135:rt-thread/src/idle.c ****      * not change within rt_thread_idle_excute thus optimize the "while" loop
 136:rt-thread/src/idle.c ****      * into a "if".
 137:rt-thread/src/idle.c ****      *
 138:rt-thread/src/idle.c ****      * So add the volatile qualifier here. */
 139:rt-thread/src/idle.c ****     const volatile rt_list_t *l = (const volatile rt_list_t *)&rt_thread_defunct;
 140:rt-thread/src/idle.c **** 
 141:rt-thread/src/idle.c ****     return l->next != l;
 142:rt-thread/src/idle.c **** }
 143:rt-thread/src/idle.c **** 
 144:rt-thread/src/idle.c **** /**
 145:rt-thread/src/idle.c ****  * @ingroup Thread
ARM GAS  /tmp/ccojy97u.s 			page 4


 146:rt-thread/src/idle.c ****  *
 147:rt-thread/src/idle.c ****  * This function will perform system background job when system idle.
 148:rt-thread/src/idle.c ****  */
 149:rt-thread/src/idle.c **** void rt_thread_idle_excute(void)
 150:rt-thread/src/idle.c **** {
  28              		.loc 1 150 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33              	.LBB10:
  34              	.LBB11:
 141:rt-thread/src/idle.c **** }
  35              		.loc 1 141 0
  36 0000 2B4B     		ldr	r3, .L17
  37 0002 1A68     		ldr	r2, [r3]
  38              	.LBE11:
  39              	.LBE10:
 151:rt-thread/src/idle.c ****     /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
 152:rt-thread/src/idle.c ****      * will do all the cleanups. */
 153:rt-thread/src/idle.c ****     while (_has_defunct_thread())
  40              		.loc 1 153 0
  41 0004 9A42     		cmp	r2, r3
  42 0006 51D0     		beq	.L13
 150:rt-thread/src/idle.c ****     /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
  43              		.loc 1 150 0
  44 0008 70B5     		push	{r4, r5, r6, lr}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 16
  47              		.cfi_offset 4, -16
  48              		.cfi_offset 5, -12
  49              		.cfi_offset 6, -8
  50              		.cfi_offset 14, -4
  51 000a 1EE0     		b	.L8
  52              	.LVL1:
  53              	.L16:
  54              	.LBB13:
  55              	.LBB14:
 154:rt-thread/src/idle.c ****     {
 155:rt-thread/src/idle.c ****         rt_base_t lock;
 156:rt-thread/src/idle.c ****         rt_thread_t thread;
 157:rt-thread/src/idle.c **** #ifdef RT_USING_MODULE
 158:rt-thread/src/idle.c ****         struct rt_dlmodule *module = RT_NULL;
 159:rt-thread/src/idle.c **** #endif
 160:rt-thread/src/idle.c ****         RT_DEBUG_NOT_IN_INTERRUPT;
  56              		.loc 1 160 0 discriminator 1
  57 000c 294D     		ldr	r5, .L17+4
  58 000e 2946     		mov	r1, r5
  59 0010 2948     		ldr	r0, .L17+8
  60 0012 FFF7FEFF 		bl	rt_kprintf
  61              	.LVL2:
  62 0016 A022     		movs	r2, #160
  63 0018 2946     		mov	r1, r5
  64 001a 2848     		ldr	r0, .L17+12
  65 001c FFF7FEFF 		bl	rt_assert_handler
  66              	.LVL3:
  67 0020 1AE0     		b	.L3
ARM GAS  /tmp/ccojy97u.s 			page 5


  68              	.LVL4:
  69              	.L5:
  70              	.LBE14:
 161:rt-thread/src/idle.c **** 
 162:rt-thread/src/idle.c ****         /* disable interrupt */
 163:rt-thread/src/idle.c ****         lock = rt_hw_interrupt_disable();
 164:rt-thread/src/idle.c **** 
 165:rt-thread/src/idle.c ****         /* re-check whether list is empty */
 166:rt-thread/src/idle.c ****         if (_has_defunct_thread())
 167:rt-thread/src/idle.c ****         {
 168:rt-thread/src/idle.c ****             /* get defunct thread */
 169:rt-thread/src/idle.c ****             thread = rt_list_entry(rt_thread_defunct.next,
 170:rt-thread/src/idle.c ****                                    struct rt_thread,
 171:rt-thread/src/idle.c ****                                    tlist);
 172:rt-thread/src/idle.c **** #ifdef RT_USING_MODULE
 173:rt-thread/src/idle.c ****             module = (struct rt_dlmodule*)thread->module_id;
 174:rt-thread/src/idle.c ****             if (module)
 175:rt-thread/src/idle.c ****             {
 176:rt-thread/src/idle.c ****                 dlmodule_destroy(module);
 177:rt-thread/src/idle.c ****             }
 178:rt-thread/src/idle.c **** #endif
 179:rt-thread/src/idle.c ****             /* remove defunct thread */
 180:rt-thread/src/idle.c ****             rt_list_remove(&(thread->tlist));
 181:rt-thread/src/idle.c **** 
 182:rt-thread/src/idle.c ****             /* lock scheduler to prevent scheduling in cleanup function. */
 183:rt-thread/src/idle.c ****             rt_enter_critical();
 184:rt-thread/src/idle.c **** 
 185:rt-thread/src/idle.c ****             /* invoke thread cleanup */
 186:rt-thread/src/idle.c ****             if (thread->cleanup != RT_NULL)
 187:rt-thread/src/idle.c ****                 thread->cleanup(thread);
 188:rt-thread/src/idle.c **** 
 189:rt-thread/src/idle.c **** #ifdef RT_USING_SIGNALS
 190:rt-thread/src/idle.c ****             rt_thread_free_sig(thread);
 191:rt-thread/src/idle.c **** #endif
 192:rt-thread/src/idle.c **** 
 193:rt-thread/src/idle.c ****             /* if it's a system object, not delete it */
 194:rt-thread/src/idle.c ****             if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
  71              		.loc 1 194 0
  72 0022 2846     		mov	r0, r5
  73 0024 FFF7FEFF 		bl	rt_object_is_systemobject
  74              	.LVL5:
  75 0028 0128     		cmp	r0, #1
  76 002a 32D0     		beq	.L14
 195:rt-thread/src/idle.c ****             {
 196:rt-thread/src/idle.c ****                 /* detach this object */
 197:rt-thread/src/idle.c ****                 rt_object_detach((rt_object_t)thread);
 198:rt-thread/src/idle.c ****                 /* unlock scheduler */
 199:rt-thread/src/idle.c ****                 rt_exit_critical();
 200:rt-thread/src/idle.c **** 
 201:rt-thread/src/idle.c ****                 /* enable interrupt */
 202:rt-thread/src/idle.c ****                 rt_hw_interrupt_enable(lock);
 203:rt-thread/src/idle.c **** 
 204:rt-thread/src/idle.c ****                 return;
 205:rt-thread/src/idle.c ****             }
 206:rt-thread/src/idle.c **** 
 207:rt-thread/src/idle.c ****             /* unlock scheduler */
 208:rt-thread/src/idle.c ****             rt_exit_critical();
ARM GAS  /tmp/ccojy97u.s 			page 6


  77              		.loc 1 208 0
  78 002c FFF7FEFF 		bl	rt_exit_critical
  79              	.LVL6:
 209:rt-thread/src/idle.c ****         }
 210:rt-thread/src/idle.c ****         else
 211:rt-thread/src/idle.c ****         {
 212:rt-thread/src/idle.c ****             /* enable interrupt */
 213:rt-thread/src/idle.c ****             rt_hw_interrupt_enable(lock);
 214:rt-thread/src/idle.c **** 
 215:rt-thread/src/idle.c ****             /* may the defunct thread list is removed by others, just return */
 216:rt-thread/src/idle.c ****             return;
 217:rt-thread/src/idle.c ****         }
 218:rt-thread/src/idle.c **** 
 219:rt-thread/src/idle.c ****         /* enable interrupt */
 220:rt-thread/src/idle.c ****         rt_hw_interrupt_enable(lock);
  80              		.loc 1 220 0
  81 0030 3046     		mov	r0, r6
  82 0032 FFF7FEFF 		bl	rt_hw_interrupt_enable
  83              	.LVL7:
 221:rt-thread/src/idle.c **** 
 222:rt-thread/src/idle.c **** #ifdef RT_USING_HEAP
 223:rt-thread/src/idle.c ****         /* release thread's stack */
 224:rt-thread/src/idle.c ****         RT_KERNEL_FREE(thread->stack_addr);
  84              		.loc 1 224 0
  85 0036 6069     		ldr	r0, [r4, #20]
  86 0038 FFF7FEFF 		bl	rt_free
  87              	.LVL8:
 225:rt-thread/src/idle.c ****         /* delete thread object */
 226:rt-thread/src/idle.c ****         rt_object_delete((rt_object_t)thread);
  88              		.loc 1 226 0
  89 003c 2846     		mov	r0, r5
  90 003e FFF7FEFF 		bl	rt_object_delete
  91              	.LVL9:
  92              	.LBE13:
  93              	.LBB20:
  94              	.LBB12:
 141:rt-thread/src/idle.c **** }
  95              		.loc 1 141 0
  96 0042 1B4B     		ldr	r3, .L17
  97 0044 1A68     		ldr	r2, [r3]
  98              	.LBE12:
  99              	.LBE20:
 153:rt-thread/src/idle.c ****     {
 100              		.loc 1 153 0
 101 0046 9A42     		cmp	r2, r3
 102 0048 2FD0     		beq	.L15
 103              	.LVL10:
 104              	.L8:
 105              	.LBB21:
 106              	.LBB15:
 160:rt-thread/src/idle.c **** 
 107              		.loc 1 160 0
 108 004a FFF7FEFF 		bl	rt_hw_interrupt_disable
 109              	.LVL11:
 110 004e 0446     		mov	r4, r0
 111              	.LVL12:
 112 0050 FFF7FEFF 		bl	rt_interrupt_get_nest
ARM GAS  /tmp/ccojy97u.s 			page 7


 113              	.LVL13:
 114 0054 0028     		cmp	r0, #0
 115 0056 D9D1     		bne	.L16
 116              	.L3:
 160:rt-thread/src/idle.c **** 
 117              		.loc 1 160 0 is_stmt 0 discriminator 5
 118 0058 2046     		mov	r0, r4
 119 005a FFF7FEFF 		bl	rt_hw_interrupt_enable
 120              	.LVL14:
 121              	.LBE15:
 163:rt-thread/src/idle.c **** 
 122              		.loc 1 163 0 is_stmt 1 discriminator 5
 123 005e FFF7FEFF 		bl	rt_hw_interrupt_disable
 124              	.LVL15:
 125 0062 0646     		mov	r6, r0
 126              	.LVL16:
 127              	.LBB16:
 128              	.LBB17:
 141:rt-thread/src/idle.c **** }
 129              		.loc 1 141 0 discriminator 5
 130 0064 124B     		ldr	r3, .L17
 131 0066 1A68     		ldr	r2, [r3]
 132              	.LBE17:
 133              	.LBE16:
 166:rt-thread/src/idle.c ****         {
 134              		.loc 1 166 0 discriminator 5
 135 0068 9A42     		cmp	r2, r3
 136 006a 1BD0     		beq	.L4
 169:rt-thread/src/idle.c ****                                    struct rt_thread,
 137              		.loc 1 169 0
 138 006c 1C68     		ldr	r4, [r3]
 139              	.LVL17:
 140 006e A4F11405 		sub	r5, r4, #20
 141              	.LVL18:
 142              	.LBB18:
 143              	.LBB19:
 144              		.file 2 "rt-thread/include/rtservice.h"
   1:rt-thread/include/rtservice.h **** /*
   2:rt-thread/include/rtservice.h ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt-thread/include/rtservice.h ****  *
   4:rt-thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rt-thread/include/rtservice.h ****  *
   6:rt-thread/include/rtservice.h ****  * Change Logs:
   7:rt-thread/include/rtservice.h ****  * Date           Author       Notes
   8:rt-thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rt-thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rt-thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rt-thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rt-thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rt-thread/include/rtservice.h ****  *                             Make code cleanup.
  14:rt-thread/include/rtservice.h ****  */
  15:rt-thread/include/rtservice.h **** 
  16:rt-thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rt-thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rt-thread/include/rtservice.h **** 
  19:rt-thread/include/rtservice.h **** #ifdef __cplusplus
  20:rt-thread/include/rtservice.h **** extern "C" {
ARM GAS  /tmp/ccojy97u.s 			page 8


  21:rt-thread/include/rtservice.h **** #endif
  22:rt-thread/include/rtservice.h **** 
  23:rt-thread/include/rtservice.h **** /**
  24:rt-thread/include/rtservice.h ****  * @addtogroup KernelService
  25:rt-thread/include/rtservice.h ****  */
  26:rt-thread/include/rtservice.h **** 
  27:rt-thread/include/rtservice.h **** /**@{*/
  28:rt-thread/include/rtservice.h **** 
  29:rt-thread/include/rtservice.h **** /**
  30:rt-thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rt-thread/include/rtservice.h ****  * struct type.
  32:rt-thread/include/rtservice.h ****  */
  33:rt-thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rt-thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rt-thread/include/rtservice.h **** 
  36:rt-thread/include/rtservice.h **** 
  37:rt-thread/include/rtservice.h **** /**
  38:rt-thread/include/rtservice.h ****  * @brief initialize a list object
  39:rt-thread/include/rtservice.h ****  */
  40:rt-thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rt-thread/include/rtservice.h **** 
  42:rt-thread/include/rtservice.h **** /**
  43:rt-thread/include/rtservice.h ****  * @brief initialize a list
  44:rt-thread/include/rtservice.h ****  *
  45:rt-thread/include/rtservice.h ****  * @param l list to be initialized
  46:rt-thread/include/rtservice.h ****  */
  47:rt-thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:rt-thread/include/rtservice.h **** {
  49:rt-thread/include/rtservice.h ****     l->next = l->prev = l;
  50:rt-thread/include/rtservice.h **** }
  51:rt-thread/include/rtservice.h **** 
  52:rt-thread/include/rtservice.h **** /**
  53:rt-thread/include/rtservice.h ****  * @brief insert a node after a list
  54:rt-thread/include/rtservice.h ****  *
  55:rt-thread/include/rtservice.h ****  * @param l list to insert it
  56:rt-thread/include/rtservice.h ****  * @param n new node to be inserted
  57:rt-thread/include/rtservice.h ****  */
  58:rt-thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rt-thread/include/rtservice.h **** {
  60:rt-thread/include/rtservice.h ****     l->next->prev = n;
  61:rt-thread/include/rtservice.h ****     n->next = l->next;
  62:rt-thread/include/rtservice.h **** 
  63:rt-thread/include/rtservice.h ****     l->next = n;
  64:rt-thread/include/rtservice.h ****     n->prev = l;
  65:rt-thread/include/rtservice.h **** }
  66:rt-thread/include/rtservice.h **** 
  67:rt-thread/include/rtservice.h **** /**
  68:rt-thread/include/rtservice.h ****  * @brief insert a node before a list
  69:rt-thread/include/rtservice.h ****  *
  70:rt-thread/include/rtservice.h ****  * @param n new node to be inserted
  71:rt-thread/include/rtservice.h ****  * @param l list to insert it
  72:rt-thread/include/rtservice.h ****  */
  73:rt-thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rt-thread/include/rtservice.h **** {
  75:rt-thread/include/rtservice.h ****     l->prev->next = n;
  76:rt-thread/include/rtservice.h ****     n->prev = l->prev;
  77:rt-thread/include/rtservice.h **** 
ARM GAS  /tmp/ccojy97u.s 			page 9


  78:rt-thread/include/rtservice.h ****     l->prev = n;
  79:rt-thread/include/rtservice.h ****     n->next = l;
  80:rt-thread/include/rtservice.h **** }
  81:rt-thread/include/rtservice.h **** 
  82:rt-thread/include/rtservice.h **** /**
  83:rt-thread/include/rtservice.h ****  * @brief remove node from list.
  84:rt-thread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:rt-thread/include/rtservice.h ****  */
  86:rt-thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rt-thread/include/rtservice.h **** {
  88:rt-thread/include/rtservice.h ****     n->next->prev = n->prev;
 145              		.loc 2 88 0
 146 0072 2368     		ldr	r3, [r4]
 147 0074 6268     		ldr	r2, [r4, #4]
 148 0076 5A60     		str	r2, [r3, #4]
  89:rt-thread/include/rtservice.h ****     n->prev->next = n->next;
 149              		.loc 2 89 0
 150 0078 6368     		ldr	r3, [r4, #4]
 151 007a 2268     		ldr	r2, [r4]
 152 007c 1A60     		str	r2, [r3]
  90:rt-thread/include/rtservice.h **** 
  91:rt-thread/include/rtservice.h ****     n->next = n->prev = n;
 153              		.loc 2 91 0
 154 007e 6460     		str	r4, [r4, #4]
 155 0080 2460     		str	r4, [r4]
 156              	.LVL19:
 157              	.LBE19:
 158              	.LBE18:
 183:rt-thread/src/idle.c **** 
 159              		.loc 1 183 0
 160 0082 FFF7FEFF 		bl	rt_enter_critical
 161              	.LVL20:
 186:rt-thread/src/idle.c ****                 thread->cleanup(thread);
 162              		.loc 1 186 0
 163 0086 E36D     		ldr	r3, [r4, #92]
 164 0088 002B     		cmp	r3, #0
 165 008a CAD0     		beq	.L5
 187:rt-thread/src/idle.c **** 
 166              		.loc 1 187 0
 167 008c 2846     		mov	r0, r5
 168 008e 9847     		blx	r3
 169              	.LVL21:
 170 0090 C7E7     		b	.L5
 171              	.L14:
 197:rt-thread/src/idle.c ****                 /* unlock scheduler */
 172              		.loc 1 197 0
 173 0092 2846     		mov	r0, r5
 174 0094 FFF7FEFF 		bl	rt_object_detach
 175              	.LVL22:
 199:rt-thread/src/idle.c **** 
 176              		.loc 1 199 0
 177 0098 FFF7FEFF 		bl	rt_exit_critical
 178              	.LVL23:
 202:rt-thread/src/idle.c **** 
 179              		.loc 1 202 0
 180 009c 3046     		mov	r0, r6
 181 009e FFF7FEFF 		bl	rt_hw_interrupt_enable
ARM GAS  /tmp/ccojy97u.s 			page 10


 182              	.LVL24:
 204:rt-thread/src/idle.c ****             }
 183              		.loc 1 204 0
 184 00a2 70BD     		pop	{r4, r5, r6, pc}
 185              	.LVL25:
 186              	.L4:
 213:rt-thread/src/idle.c **** 
 187              		.loc 1 213 0
 188 00a4 FFF7FEFF 		bl	rt_hw_interrupt_enable
 189              	.LVL26:
 216:rt-thread/src/idle.c ****         }
 190              		.loc 1 216 0
 191 00a8 70BD     		pop	{r4, r5, r6, pc}
 192              	.LVL27:
 193              	.L15:
 194 00aa 70BD     		pop	{r4, r5, r6, pc}
 195              	.LVL28:
 196              	.L13:
 197              	.LCFI1:
 198              		.cfi_def_cfa_offset 0
 199              		.cfi_restore 4
 200              		.cfi_restore 5
 201              		.cfi_restore 6
 202              		.cfi_restore 14
 203 00ac 7047     		bx	lr
 204              	.L18:
 205 00ae 00BF     		.align	2
 206              	.L17:
 207 00b0 00000000 		.word	rt_thread_defunct
 208 00b4 00000000 		.word	.LANCHOR0
 209 00b8 00000000 		.word	.LC0
 210 00bc 28000000 		.word	.LC1
 211              	.LBE21:
 212              		.cfi_endproc
 213              	.LFE16:
 215              		.section	.text.rt_thread_idle_entry,"ax",%progbits
 216              		.align	1
 217              		.syntax unified
 218              		.thumb
 219              		.thumb_func
 220              		.fpu fpv4-sp-d16
 222              	rt_thread_idle_entry:
 223              	.LFB17:
 227:rt-thread/src/idle.c **** #endif
 228:rt-thread/src/idle.c ****     }
 229:rt-thread/src/idle.c **** }
 230:rt-thread/src/idle.c **** 
 231:rt-thread/src/idle.c **** extern void rt_system_power_manager(void);
 232:rt-thread/src/idle.c **** static void rt_thread_idle_entry(void *parameter)
 233:rt-thread/src/idle.c **** {
 224              		.loc 1 233 0
 225              		.cfi_startproc
 226              		@ Volatile: function does not return.
 227              		@ args = 0, pretend = 0, frame = 0
 228              		@ frame_needed = 0, uses_anonymous_args = 0
 229              	.LVL29:
 230 0000 08B5     		push	{r3, lr}
ARM GAS  /tmp/ccojy97u.s 			page 11


 231              	.LCFI2:
 232              		.cfi_def_cfa_offset 8
 233              		.cfi_offset 3, -8
 234              		.cfi_offset 14, -4
 235              	.LVL30:
 236              	.L20:
 234:rt-thread/src/idle.c **** #ifdef RT_USING_SMP
 235:rt-thread/src/idle.c ****     if (rt_hw_cpu_id() != 0)
 236:rt-thread/src/idle.c ****     {
 237:rt-thread/src/idle.c ****         while (1)
 238:rt-thread/src/idle.c ****         {
 239:rt-thread/src/idle.c ****             rt_hw_secondary_cpu_idle_exec();
 240:rt-thread/src/idle.c ****         }
 241:rt-thread/src/idle.c ****     }
 242:rt-thread/src/idle.c **** #endif
 243:rt-thread/src/idle.c **** 
 244:rt-thread/src/idle.c ****     while (1)
 245:rt-thread/src/idle.c ****     {
 246:rt-thread/src/idle.c **** #ifdef RT_USING_IDLE_HOOK
 247:rt-thread/src/idle.c ****         rt_size_t i;
 248:rt-thread/src/idle.c **** 
 249:rt-thread/src/idle.c ****         for (i = 0; i < RT_IDLE_HOOK_LIST_SIZE; i++)
 250:rt-thread/src/idle.c ****         {
 251:rt-thread/src/idle.c ****             if (idle_hook_list[i] != RT_NULL)
 252:rt-thread/src/idle.c ****             {
 253:rt-thread/src/idle.c ****                 idle_hook_list[i]();
 254:rt-thread/src/idle.c ****             }
 255:rt-thread/src/idle.c ****         }
 256:rt-thread/src/idle.c **** #endif
 257:rt-thread/src/idle.c **** 
 258:rt-thread/src/idle.c ****         rt_thread_idle_excute();
 237              		.loc 1 258 0 discriminator 1
 238 0002 FFF7FEFF 		bl	rt_thread_idle_excute
 239              	.LVL31:
 240 0006 FCE7     		b	.L20
 241              		.cfi_endproc
 242              	.LFE17:
 244              		.section	.text.rt_thread_idle_init,"ax",%progbits
 245              		.align	1
 246              		.global	rt_thread_idle_init
 247              		.syntax unified
 248              		.thumb
 249              		.thumb_func
 250              		.fpu fpv4-sp-d16
 252              	rt_thread_idle_init:
 253              	.LFB18:
 259:rt-thread/src/idle.c **** #ifdef RT_USING_PM        
 260:rt-thread/src/idle.c ****         rt_system_power_manager();
 261:rt-thread/src/idle.c **** #endif
 262:rt-thread/src/idle.c ****     }
 263:rt-thread/src/idle.c **** }
 264:rt-thread/src/idle.c **** 
 265:rt-thread/src/idle.c **** /**
 266:rt-thread/src/idle.c ****  * @ingroup SystemInit
 267:rt-thread/src/idle.c ****  *
 268:rt-thread/src/idle.c ****  * This function will initialize idle thread, then start it.
 269:rt-thread/src/idle.c ****  *
ARM GAS  /tmp/ccojy97u.s 			page 12


 270:rt-thread/src/idle.c ****  * @note this function must be invoked when system init.
 271:rt-thread/src/idle.c ****  */
 272:rt-thread/src/idle.c **** void rt_thread_idle_init(void)
 273:rt-thread/src/idle.c **** {
 254              		.loc 1 273 0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 8
 257              		@ frame_needed = 0, uses_anonymous_args = 0
 258 0000 30B5     		push	{r4, r5, lr}
 259              	.LCFI3:
 260              		.cfi_def_cfa_offset 12
 261              		.cfi_offset 4, -12
 262              		.cfi_offset 5, -8
 263              		.cfi_offset 14, -4
 264 0002 87B0     		sub	sp, sp, #28
 265              	.LCFI4:
 266              		.cfi_def_cfa_offset 40
 267              	.LVL32:
 274:rt-thread/src/idle.c ****     rt_ubase_t i;
 275:rt-thread/src/idle.c ****     char tidle_name[RT_NAME_MAX];
 276:rt-thread/src/idle.c **** 
 277:rt-thread/src/idle.c ****     for (i = 0; i < _CPUS_NR; i++)
 268              		.loc 1 277 0
 269 0004 0024     		movs	r4, #0
 270              	.LVL33:
 271              	.L23:
 272              		.loc 1 277 0 is_stmt 0 discriminator 1
 273 0006 0CB1     		cbz	r4, .L24
 278:rt-thread/src/idle.c ****     {
 279:rt-thread/src/idle.c ****         rt_sprintf(tidle_name, "tidle%d", i);
 280:rt-thread/src/idle.c ****         rt_thread_init(&idle[i],
 281:rt-thread/src/idle.c ****                 tidle_name,
 282:rt-thread/src/idle.c ****                 rt_thread_idle_entry,
 283:rt-thread/src/idle.c ****                 RT_NULL,
 284:rt-thread/src/idle.c ****                 &rt_thread_stack[i][0],
 285:rt-thread/src/idle.c ****                 sizeof(rt_thread_stack[i]),
 286:rt-thread/src/idle.c ****                 RT_THREAD_PRIORITY_MAX - 1,
 287:rt-thread/src/idle.c ****                 32);
 288:rt-thread/src/idle.c **** #ifdef RT_USING_SMP
 289:rt-thread/src/idle.c ****         rt_thread_control(&idle[i], RT_THREAD_CTRL_BIND_CPU, (void*)i);
 290:rt-thread/src/idle.c **** #endif
 291:rt-thread/src/idle.c ****         /* startup */
 292:rt-thread/src/idle.c ****         rt_thread_startup(&idle[i]);
 293:rt-thread/src/idle.c ****     }
 294:rt-thread/src/idle.c **** }
 274              		.loc 1 294 0 is_stmt 1
 275 0008 07B0     		add	sp, sp, #28
 276              	.LCFI5:
 277              		.cfi_remember_state
 278              		.cfi_def_cfa_offset 12
 279              		@ sp needed
 280 000a 30BD     		pop	{r4, r5, pc}
 281              	.LVL34:
 282              	.L24:
 283              	.LCFI6:
 284              		.cfi_restore_state
 279:rt-thread/src/idle.c ****         rt_thread_init(&idle[i],
ARM GAS  /tmp/ccojy97u.s 			page 13


 285              		.loc 1 279 0 discriminator 3
 286 000c 2246     		mov	r2, r4
 287 000e 0F49     		ldr	r1, .L26
 288 0010 04A8     		add	r0, sp, #16
 289 0012 FFF7FEFF 		bl	rt_sprintf
 290              	.LVL35:
 280:rt-thread/src/idle.c ****                 tidle_name,
 291              		.loc 1 280 0 discriminator 3
 292 0016 C4EB0412 		rsb	r2, r4, r4, lsl #4
 293 001a D300     		lsls	r3, r2, #3
 294 001c 0C4D     		ldr	r5, .L26+4
 295 001e 1D44     		add	r5, r5, r3
 284:rt-thread/src/idle.c ****                 sizeof(rt_thread_stack[i]),
 296              		.loc 1 284 0 discriminator 3
 297 0020 0C4B     		ldr	r3, .L26+8
 298 0022 03EB4423 		add	r3, r3, r4, lsl #9
 280:rt-thread/src/idle.c ****                 tidle_name,
 299              		.loc 1 280 0 discriminator 3
 300 0026 2022     		movs	r2, #32
 301 0028 0392     		str	r2, [sp, #12]
 302 002a 1F22     		movs	r2, #31
 303 002c 0292     		str	r2, [sp, #8]
 304 002e 4FF40072 		mov	r2, #512
 305 0032 0192     		str	r2, [sp, #4]
 306 0034 0093     		str	r3, [sp]
 307 0036 0023     		movs	r3, #0
 308 0038 074A     		ldr	r2, .L26+12
 309 003a 04A9     		add	r1, sp, #16
 310 003c 2846     		mov	r0, r5
 311 003e FFF7FEFF 		bl	rt_thread_init
 312              	.LVL36:
 292:rt-thread/src/idle.c ****     }
 313              		.loc 1 292 0 discriminator 3
 314 0042 2846     		mov	r0, r5
 315 0044 FFF7FEFF 		bl	rt_thread_startup
 316              	.LVL37:
 277:rt-thread/src/idle.c ****     {
 317              		.loc 1 277 0 discriminator 3
 318 0048 0134     		adds	r4, r4, #1
 319              	.LVL38:
 320 004a DCE7     		b	.L23
 321              	.L27:
 322              		.align	2
 323              	.L26:
 324 004c 00000000 		.word	.LC2
 325 0050 00000000 		.word	.LANCHOR1
 326 0054 00000000 		.word	.LANCHOR2
 327 0058 00000000 		.word	rt_thread_idle_entry
 328              		.cfi_endproc
 329              	.LFE18:
 331              		.section	.text.rt_thread_idle_gethandler,"ax",%progbits
 332              		.align	1
 333              		.global	rt_thread_idle_gethandler
 334              		.syntax unified
 335              		.thumb
 336              		.thumb_func
 337              		.fpu fpv4-sp-d16
ARM GAS  /tmp/ccojy97u.s 			page 14


 339              	rt_thread_idle_gethandler:
 340              	.LFB19:
 295:rt-thread/src/idle.c **** 
 296:rt-thread/src/idle.c **** /**
 297:rt-thread/src/idle.c ****  * @ingroup Thread
 298:rt-thread/src/idle.c ****  *
 299:rt-thread/src/idle.c ****  * This function will get the handler of the idle thread.
 300:rt-thread/src/idle.c ****  *
 301:rt-thread/src/idle.c ****  */
 302:rt-thread/src/idle.c **** rt_thread_t rt_thread_idle_gethandler(void)
 303:rt-thread/src/idle.c **** {
 341              		.loc 1 303 0
 342              		.cfi_startproc
 343              		@ args = 0, pretend = 0, frame = 0
 344              		@ frame_needed = 0, uses_anonymous_args = 0
 345              		@ link register save eliminated.
 346              	.LVL39:
 304:rt-thread/src/idle.c **** #ifdef RT_USING_SMP
 305:rt-thread/src/idle.c ****     register int id = rt_hw_cpu_id();
 306:rt-thread/src/idle.c **** #else
 307:rt-thread/src/idle.c ****     register int id = 0;
 308:rt-thread/src/idle.c **** #endif
 309:rt-thread/src/idle.c **** 
 310:rt-thread/src/idle.c ****     return (rt_thread_t)(&idle[id]);
 311:rt-thread/src/idle.c **** }
 347              		.loc 1 311 0
 348 0000 0048     		ldr	r0, .L29
 349 0002 7047     		bx	lr
 350              	.L30:
 351              		.align	2
 352              	.L29:
 353 0004 00000000 		.word	.LANCHOR1
 354              		.cfi_endproc
 355              	.LFE19:
 357              		.section	.bss.idle,"aw",%nobits
 358              		.align	2
 359              		.set	.LANCHOR1,. + 0
 362              	idle:
 363 0000 00000000 		.space	120
 363      00000000 
 363      00000000 
 363      00000000 
 363      00000000 
 364              		.section	.bss.rt_thread_stack,"aw",%nobits
 365              		.align	2
 366              		.set	.LANCHOR2,. + 0
 369              	rt_thread_stack:
 370 0000 00000000 		.space	512
 370      00000000 
 370      00000000 
 370      00000000 
 370      00000000 
 371              		.section	.rodata.__FUNCTION__.6526,"a",%progbits
 372              		.align	2
 373              		.set	.LANCHOR0,. + 0
 376              	__FUNCTION__.6526:
 377 0000 72745F74 		.ascii	"rt_thread_idle_excute\000"
ARM GAS  /tmp/ccojy97u.s 			page 15


 377      68726561 
 377      645F6964 
 377      6C655F65 
 377      78637574 
 378              		.section	.rodata.rt_thread_idle_excute.str1.4,"aMS",%progbits,1
 379              		.align	2
 380              	.LC0:
 381 0000 46756E63 		.ascii	"Function[%s] shall not be used in ISR\012\000"
 381      74696F6E 
 381      5B25735D 
 381      20736861 
 381      6C6C206E 
 382 0027 00       		.space	1
 383              	.LC1:
 384 0028 3000     		.ascii	"0\000"
 385              		.section	.rodata.rt_thread_idle_init.str1.4,"aMS",%progbits,1
 386              		.align	2
 387              	.LC2:
 388 0000 7469646C 		.ascii	"tidle%d\000"
 388      65256400 
 389              		.text
 390              	.Letext0:
 391              		.file 3 "rt-thread/include/rtdef.h"
 392              		.file 4 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/lock.h"
 393              		.file 5 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/_types.h"
 394              		.file 6 "/opt/gcc-arm-none-eabi-6-2017-q2-update/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 395              		.file 7 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/reent.h"
 396              		.file 8 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/time.h"
 397              		.file 9 "/opt/gcc-arm-none-eabi-6-2017-q2-update/arm-none-eabi/include/sys/errno.h"
 398              		.file 10 "rt-thread/include/rtthread.h"
 399              		.file 11 "rt-thread/include/rthw.h"
ARM GAS  /tmp/ccojy97u.s 			page 16


DEFINED SYMBOLS
                            *ABS*:0000000000000000 idle.c
     /tmp/ccojy97u.s:18     .text.rt_thread_idle_excute:0000000000000000 $t
     /tmp/ccojy97u.s:25     .text.rt_thread_idle_excute:0000000000000000 rt_thread_idle_excute
     /tmp/ccojy97u.s:207    .text.rt_thread_idle_excute:00000000000000b0 $d
     /tmp/ccojy97u.s:216    .text.rt_thread_idle_entry:0000000000000000 $t
     /tmp/ccojy97u.s:222    .text.rt_thread_idle_entry:0000000000000000 rt_thread_idle_entry
     /tmp/ccojy97u.s:245    .text.rt_thread_idle_init:0000000000000000 $t
     /tmp/ccojy97u.s:252    .text.rt_thread_idle_init:0000000000000000 rt_thread_idle_init
     /tmp/ccojy97u.s:324    .text.rt_thread_idle_init:000000000000004c $d
     /tmp/ccojy97u.s:332    .text.rt_thread_idle_gethandler:0000000000000000 $t
     /tmp/ccojy97u.s:339    .text.rt_thread_idle_gethandler:0000000000000000 rt_thread_idle_gethandler
     /tmp/ccojy97u.s:353    .text.rt_thread_idle_gethandler:0000000000000004 $d
     /tmp/ccojy97u.s:358    .bss.idle:0000000000000000 $d
     /tmp/ccojy97u.s:362    .bss.idle:0000000000000000 idle
     /tmp/ccojy97u.s:365    .bss.rt_thread_stack:0000000000000000 $d
     /tmp/ccojy97u.s:369    .bss.rt_thread_stack:0000000000000000 rt_thread_stack
     /tmp/ccojy97u.s:372    .rodata.__FUNCTION__.6526:0000000000000000 $d
     /tmp/ccojy97u.s:376    .rodata.__FUNCTION__.6526:0000000000000000 __FUNCTION__.6526
     /tmp/ccojy97u.s:379    .rodata.rt_thread_idle_excute.str1.4:0000000000000000 $d
     /tmp/ccojy97u.s:386    .rodata.rt_thread_idle_init.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rt_kprintf
rt_assert_handler
rt_object_is_systemobject
rt_exit_critical
rt_hw_interrupt_enable
rt_free
rt_object_delete
rt_hw_interrupt_disable
rt_interrupt_get_nest
rt_enter_critical
rt_object_detach
rt_thread_defunct
rt_sprintf
rt_thread_init
rt_thread_startup
